# ПРОЕКТ НАХОДИТСЯ НА СТАДИИ РАЗРАБОТКИ И МНОГИЕ ФОРМЫ НЕ ГОТОВЫ !

# Общая информация
### Название проект: Black SMM
### Задачи: работа с аккаунтами и API telegram
### Задускать через app/start.py или app/start.exe

## Содержание 

1. [**Общая информация**](#общая-информация)
2. [**Содержание**](#содержание-)
3. [**Список зависимостей и необходимых инструментов**](#список-зависимостей-и-необходимых-инструментов)
4. [**Расположение файлов в проекте**](#расположение-файлов-в-проекте)
5. [**БД**](#бд)
6. [**Запуск приложения**](#запуск-приложения) 
7. [**Файлы для всех разделов (general)**](#файлы-для-всех-разделов-general)<br>
7.1 [Проверка прокси (check_proxy.py)](#проверка-прокси-check_proxypy) <br>
7.2 [Обработчик ошибок (error_handler.py)](#обработчик-ошибок-error_handlerpy) <br>
7.3 [Диалоговое окно при, ошибки прокси для загрузки аккаунтов (error_proxy.py)](#диалоговое-окно-при-ошибке-прокси-для-загрузки-аккаунтов-error_proxypy) <br>
7.4 [Диалоговое окно при, ошибки прокси для работы с другими разделами (error_proxy_for_work.py)](#диалоговое-окно-при-ошибке-прокси-для-работы-с-другими-разделами-error_proxy_for_workpy) <br>
7.5 [Диалоговое окно с информацией (info.py)](#диалоговое-окно-с-информацией-infopy) <br>
7.6 [Диалоговое окно с выбором "ок или отмена" (ok_or_cancel.py)](#диалоговое-окно-с-выбором-ок-или-отмена-ok_or_cancelpy) <br>
7.7 [Диалоговое окно с выбором "да или отмена" (yes_or_cancel.py)](#диалоговое-окно-с-выбором-да-или-отмена-yes_or_cancelpy) <br>
7.8 [Проверка HTML разметки (check_html_parse)](#проверка-html-разметки-check_html_parsepy) <br>
8. [**Раздел аккаунты (accounts)**](#главный-раздел-аккаунтов-accountspy) <br>
8.1 [Главный раздел (accounts.py)](#главный-раздел-аккаунтов-accountspy) <br>
8.2 [Добавление новых аккаунтов (add_accounts.py)](#добавление-новых-аккаунтов-add_accountspy) <br>
8.3 [Ошибка при добавлении нового аккаунта (error_add_accounts.py)](#ошибка-при-добавлении-нового-аккаунта-error_add_accountspy) <br>
8.4 [Ошибка открытия аккаунта при добавлении нового аккаунта (error_open_accounts.py)](#ошибка-открытия-аккаунта-при-добавлении-нового-аккаунта-error_open_accountspy) <br>
8.5 [Получение geo по номеру (flag.py)](#получение-geo-по-номеру-flagpy) <br>
8.6 [Информация о добавлении аккаунтов (info_add_accounts.py)](#информация-о-добавлении-аккаунтов-info_add_accountspy) <br>
8.7 [Информация о выборе папке для добавления аккаунтов (info_add_folder_accounts.py)](#информация-о-выборе-папке-для-добавления-аккаунтов-info_add_folder_accountspy) <br>
8.8 [Полная информация о выбранном аккаунте (more_info_accounts.py)](#полная-информация-о-выбранном-аккаунте-more_info_accountpy) <br>
9. [**Раздел конвертирование сессии**](#раздел-конвертирование-сессии-convertpy) <br>
9.1 [Главный раздел (convert.py)](#главный-раздел-convertpy) <br>
10. [**Раздел создание каналов**](#раздел-создание-каналов-create_channelpy) <br>
10.1 [Главный раздел (create_channel.py)](#главный-раздел-create_channelpy) <br>
10.2 [Диалоговое окно с первым сообщением в канал (first_message_for_group.py)](#диалоговое-окно-с-первым-сообщением-в-канал-first_message_for_grouppy) <br>
10.3 [Диалоговое окно с созданными каналами (list_created_channel.py)](#диалоговое-окно-с-созданными-каналами-list_created_channelpy) <br>
10.4 [Диалоговое окно с формированием user_name для канала (user_name_for_channel.py)](#диалоговое-окно-с-формированием-user_name-для-канала-user_name_for_channelpy) <br>
11. [**Раздел инвайт**](#раздел-инвайт-invitepy-) <br>
11.1 [Главный раздел (invite.py)](#главный-раздел-invitepy-) <br>
12. [**Раздел рассылка по Юзерам**](#раздел-рассылка-по-юзерам-mailing_by_userspy) <br>
12.1 [Главный раздел (mailing_by_users.py)](#главный-раздел-mailing_by_userspy) <br>
13. [**Раздел парсинг**](#раздел-парсинг-parserpy) <br>
13.1 [Главный раздел (parser.py)](#главный-раздел-parserpy) <br>
14. [**Раздел прокси**](#раздел-прокси-proxypy-) <br>
14.1[Главный раздел (proxy.py)](#главный-раздел-proxypy-) <br>

## Список зависимостей и необходимых инструментов

### Версия Python: 3.12 
**ВНИМАНИЕ!** <br>
на других версиях библиотека opentele работает не корректно<br>

### Установленные библиотеки:
PyQt5 (для GUI)<br>
opentele (для открытия tdata)<br>
telethon (для работы с аккаунтами) <br>
phonenumbers (для определения geo)<br>
PySocks (для прокси) <br>
pygame (для проигрывания звуков) <br>
rarfile (для распаковки архива) <br>
py7zr (для распаковки архива) <br>
requests (для запросов) <br>
aiohttp (для проверки прокси) <br>
aiohttp-socks (для проверки прокси) <br>
bs4 (для проверки HTML разметки в функции [check_html_parse](#проверка-html-разметки-check_html_parsepy))
pytz (для временных зон)

**ВНИМАНИЕ!** <br>
Библиотека opentele установленна c gitHib так как только там есть последняя версия. 
Необходимо для открытия нового формата tdata


## Расположение файлов в проекте

### Папка accounts содержит папки:
active_accounts <br>
archive_accounts <br>
login_error_accounts <br>
main_accounts <br>
temporary_ban_accounts <br>

В каждой такой папке находятся папки с нумерации 0, 1, 2 ... 
(Количество такой нумерации зависит количества аккаунтов). <br>
В каждой такой пронумерованной папке содержится папка **tdata** и файл **session.session**. <br>
Наличие файла **session** не обязательно, так как он создаётся заново каждый раз при входе в аккаунт.  <br>
**Tdata** это папка с необходимыми данными для входа в аккаунт. <br>

**Какие аккаунты хранят папки: <br>** 
**active_accounts** - аккаунты, которые используются для всех действий в программе. <br>
**archive_accounts** - аккаунты, которые просто хранятся в программе, нигде не используются.<br>
**login_error_accounts** - аккаунты с ошибкой входа, нигде не используются. <br>
**main_accounts** - аккаунты, которые приглашают другие аккаунты при инвайте.<br>
**temporary_ban_accounts** - аккаунты со спамблоком <br>

### Директория app содержит:
Все папки с файлами .py рассортированные по назначению
В каждой такой папке находится ui и views <br>
ui - форма и его элементы. Сгенерировано при помощи Qt Designer
views - реализация событий на форме 

### Директория resources содержит:
Папка autofill -> avatar_picture в ней хранятся папки man, neutral, woman. <br>
в них же фотографиями для автозаполнения. <br>
Имена этих папок отображают какие аватарки по гендеру в них хранятся. <br>

Папка icon содержит необходимые для работы фотографии и gif. <br>
Папка panel содержит фотографии для левой панели выбора функций программы. <br>
Папка pictures_flag содержит фотографии флагов. <br>
Папка sounds содержит звуки.

### Директория Telegram Desktop содержит телеграмм.

### Директория working_files содержит:
Папка convert_file необходима для хранения файла с расширением .session и папки tdata (используется при конвертировании аккаунта) <br>
Папка error_enter_accounts содержит список аккаунтов с которыми произошла ошибка при добавлении в программу (очищается автоматически) <br>
Папка file_from_user содержит файла, который указал пользователь для рассылки (очищается автоматически) <br>
Папка for_create_channel содержит другие папки необходимые для создания канала <br>
Папка for_create_channel/file_for_first_message содержит файл для первого сообщения в канал <br>
Папка for_create_channel/photo_for_avatar_channel содержит изображения для установления их в аватар канала <br>
Папка test_account тут проверяется аккаунт который указал пользователь для добавления (очищается автоматически) <br>
data_base.sqlite3 - база данных для работы с данными об аккаунте, а так же хранит настройками <br>
data_base_for_parsing.sqlite3 - база данных хранящая имена в разных форматах для парсинга <br>
user_names_for_mailing.txt - список аккаунтов для рассылки <br>
user_names_for_mailing.txt - список аккаунтов для инвайта <br>
parsing_result.txt - список аккаунтов c результата парсинга <br>

## БД
Если данные в БД содержат 0 или 1 это True или False. <br>

В скобочках после названия аккаунта написан тип данных. <br>
Пример: столбец **id** (int)

Все данные отображающие время записаны в формате: часы:минуты день-месяц-год.

### data_base.sqlite3
### таблица accounts:
Содержит информацию об аккаунте. <br>

Cтолбец **id** (int) отображает какая папка присвоена этому аккаунту. <br>
Столбец **account_status** (str) отображает в какой папке находится аккаунт. Пример папки active_accounts, main_accounts... <br>
Столбец **account_status** (str) может содержать ТОЛЬКО такие значения: active, archive, login_error, main, temporary_ban <br>
Столбец **error** и **solution_error**(str) по умолчанию None, но заполняется в том случае, если получили ошибку на аккаунте <br>

Столбец **data_time_add** (str) содержит дату и время добавления аккаунта в программу.<br>
Столбец **last_used** (str) содержит дату последнего использования аккаунта. <br>

Такие столбцы как **id_tg** (int), **user_name** (str), **name** (str), **phone** (str) содержать информацию, полученную с аккаунта.

### Таблица autofill_data:
Содержит данные для автозаполнения.

Столбец **gender** (str) отображает гендер только для столбцов **name** и **surname**. <br>
Столбец **description** (str) необходим для заполнения БИО аккаунта. 

### Таблица autofill_settings:
Содержит сохранённые настройки для автозаполнения аккаунтов.

Столбец **use** (int) отображает надо ли использовать автозаполнение (может содержать только 0 или 1). <br>
Столбцы **avatar** (str), **name** (str), **surname** (str) отображают по какому гендеру необходимо заполнить аккаунт.
Может содержать **ТОЛЬКО** такие значения: **None**, **man**, **neutral**, **woman**. <br>
Столбцы **user_name** (int), **description** (int) отображает надо ли заполнять эти данные (может содержать только 0 или 1). <br>

### Таблица proxy:
В ней хранятся данные для прокси и необходимость использовать прокси при показе аккаунтов.

Столбцы **ip** (str), **port** (int), **login** (str), **password** (str) хранят информацию о прокси. <br>
Столбец **use_proxy_to_enter** (int) отображает необходимость использовать прокси при показе аккаунтов.

### Таблица saved_data_creating_channels
Хранятся данные для полей в [create_channel](#главный-раздел-create_channelpy) которые заполнил пользователь 

Столбец **name** (str) имя для каналов.
Столбец **description** (str) описание для каналов.
Столбец **max_creating_channel_from_one_account** (str) максимум созданных каналов с одного аккаунта.
Столбец **delay** (str) задержка между созданием.
Столбец **first_user_name_list** (str) первый список для формирования user_name канала.
Столбец **second_user_name_list** (str) второй список для формирования user_name канала.
Столбец **third_user_name_list** (str) третий список для формирования user_name канала.
Столбец **new_message** (str) первое сообщение в канал.
Столбец **forwarding_username** (str) user name канала для пересылки сообщения.
Столбец **forwarding_id_message** (str) id сообщения для пересылки сообщения.

### data_base_for_parsing.sqlite3 
В данной БД хранятся все мужские имена и все женские (без учёта их других форм. Пример: "Тёмочка")<br>

### Таблица man:
Содержит мужские имена написанные как на русском языке так и на английском

### Таблица man_rus:
Содержит мужские имена написанные на русском языке

### Таблица man_eng:
Содержит мужские имена написанные на английском языке

### Таблица woman:
Содержит женские имена написанные как на русском языке так и на английском

### Таблица woman_rus:
Содержит женские имена написанные на русском языке

### Таблица woman_eng:
Содержит женские имена написанные на английском языке


## Запуск приложения

Запуск приложения происходит через следующий файл: app/start.py

Перед созданием экземпляра класса с окном, проверяем есть ли интернет через запрос: <br>
`response = requests.get("http://www.google.com", timeout=5)` <br>
если его нет, то не запустим приложение и выведем соответсвующие сообщение. <br>
так же берём имя нашего приложения и ищём его в запущенных процессах
```
script_name = os.path.basename(__file__)  # Получаем имя текущего скрипта 
for process in psutil.process_iter(['pid', 'name']): 
   try:
     if script_name in process.info['name']: # Проверка по имени процесса
```

Если такой процесс уже запушен,
то выводим соответствующие сообщение пользователю и не разрешаем открыть приложение.

Если всё выше не произошло, то создаём экземпляр класса MainWindow

В MainWindow находится один элемент "stacked_widget" в который в дальнейшем помещается другие окна. <br>

Изначально создаём экземпляры класса (внутри MainWindow). <br>
Пример: `self.accounts_window = WindowAccounts(self.switch_window)` <br>
После добавляем эти элементы и запускаем первым окном окно с аккаунтами. <br>

В MainWindow имеется одна функция "switch_window" через неё происходи переключение между вкладками. <br>
Принимаемый параметр: target_window: str - вкладка которую необходимо открыть.

## Внимание! Если это форма, то описываются только файлы из директорий views! Элементы на ней не описываются!

## Файлы для всех разделов (general)

# Проверка прокси (check_proxy.py)

## Общее описание
Модуль `check_proxy.py` предоставляет функционал для работы с SOCKS5 прокси-серверами в проекте Black SMM. Основные возможности:
- Настройка SOCKS5 прокси для всех сетевых соединений
- Проверка доступности и работоспособности прокси-серверов
- Поддержка прокси с аутентификацией и без

**Ключевые особенности:**
- Глобальная настройка прокси на уровне socket
- Интеграция с [`requests`]() и другими сетевыми библиотеками
- Возврат внешнего IP при успешной проверке
- Обработка различных ошибок подключения

## Импортируемые модули
- [`requests`]() - для выполнения HTTP-запросов через прокси
- [`socks`]() (из PySocks) - для работы с SOCKS прокси
- [`socket`]() - для глобальной настройки прокси на уровне системы

## Функции

### `_set_socks5_proxy(proxy_host: str, proxy_port: int, username: str = None, password: str = None)`
**Описание:**  
Внутренняя функция для настройки SOCKS5 прокси на системном уровне. Заменяет стандартный socket на SOCKS socket.

**Параметры:**
- `proxy_host` (str): IP-адрес или доменное имя прокси-сервера
- `proxy_port` (int): Порт прокси-сервера
- `username` (str, optional): Логин для аутентификации на прокси. По умолчанию `None`
- `password` (str, optional): Пароль для аутентификации на прокси. По умолчанию `None`

**Логика работы:**
1. Формирует строку подключения к прокси:
   - С аутентификацией: `socks5://user:pass@host:port`
   - Без аутентификации: `socks5://host:port`
2. Устанавливает прокси как дефолтный через `socks.set_default_proxy()`
3. Заменяет стандартный socket на `socks.socksocket`

**Пример использования:**
```python
_set_socks5_proxy("45.144.169.213", 8000, "BVJNQe", "qXe5aX")
```

**Примечания:**
- Изменения применяются глобально для всех сетевых соединений
- Для восстановления оригинального socket необходимо сохранить его до вызова функции

---

### `check_proxy(proxy_host: str, proxy_port: int, username: str = None, password: str = None) -> Union[str, bool]`
**Описание:**  
Основная функция для проверки работоспособности прокси-сервера. Отправляет тестовый запрос к http://httpbin.org/ip и анализирует ответ.

**Параметры:**
- `proxy_host` (str): IP-адрес или доменное имя прокси-сервера
- `proxy_port` (int): Порт прокси-сервера
- `username` (str, optional): Логин для аутентификации. По умолчанию `None`
- `password` (str, optional): Пароль для аутентификации. По умолчанию `None`

**Возвращаемое значение:**
- `str` - Внешний IP-адрес, если прокси работает и запрос успешен
- `bool` - `False`, если прокси не работает или произошла ошибка

**Логика работы:**
1. Сохраняет оригинальный socket для последующего восстановления
2. Настраивает прокси через [`_set_socks5_proxy`](#_set_socks5_proxyproxy_host-str-proxy_port-int-username-str--none-password-str--none)
3. Отправляет GET-запрос к http://httpbin.org/ip с таймаутом 5 секунд
4. Анализирует ответ:
   - При статусе 200 извлекает IP из JSON-ответа
   - При других статусах или ошибках возвращает `False`
5. Восстанавливает оригинальный socket
6. Обрабатывает исключения:
   - [`requests.exceptions.ConnectionError`]() - ошибка подключения
   - Общие исключения - другие ошибки

**Пример использования:**
```python
result = check_proxy("45.144.169.213", 8000, "BVJNQe", "qXe5aX")
if result:
    print(f"Прокси работает, внешний IP: {result}")
else:
    print("Прокси не работает")
```

**Особенности реализации:**
- Использует глобальную замену socket, что влияет на все последующие соединения
- Автоматически восстанавливает оригинальный socket после проверки
- Поддерживает как аутентифицированные, так и открытые прокси
- Имеет жесткий таймаут 5 секунд на выполнение запроса

## Интеграция с другими модулями
Модуль используется в:
- [`accounts.py`](#главный-раздел-аккаунтов-accountspy) - для проверки прокси перед загрузкой аккаунтов
- [`proxy.py`](#главный-раздел-proxypy-) - в настройках прокси
- [`error_proxy.py`](#диалоговое-окно-при-ошибке-прокси-для-загрузки-аккаунтов-error_proxypy) - при обработке ошибок подключения

## Пример полного использования
```python
# Проверка прокси без аутентификации
proxy_ip = "192.168.1.1"
proxy_port = 1080
result = check_proxy(proxy_ip, proxy_port)

# Проверка прокси с аутентификацией
auth_result = check_proxy("10.0.0.1", 8080, "user", "pass")
```

## Обработка ошибок
Функция обрабатывает следующие типы ошибок:
- Неверные данные прокси
- Таймаут подключения
- Ошибки аутентификации
- Проблемы с интернет-соединением
- Ошибки сервера httpbin.org

Во всех случаях ошибок функция возвращает `False` и гарантирует восстановление оригинального socket.

## Обработчик ошибок (error_handler.py)

**Функция "get_description_and_solution": <br>**

**def get_description_and_solution(error: str):**

**Описание:<br>**
Вызывается когда произошла ошибка при работе с аккаунтами. <br>
Возвращает ошибку и её решение.

**Параметры:<br>**
- error (str): Полученная ошибка 

**Возвращаемое значение:**
- list: возвращает первым параметром списка ошибку(str), вторым её решение(str)


**Функция "error_handler": <br>**

**def error_handler(error: str,id_folder: int,account_type: str):**

**Описание:<br>**
Вызывает функцию get_description_and_solution() для получения описания ошибки и её решения. <br>
Вызывает функции **_change_folder** и **_change_db**, исходя из ошибки передаём туда определённые параметры. <br>
Концом функции будет перемещение аккаунта с ошибкой в необходимую папку, <br>
изменение последовательности id в папке откуда поступил аккаунт и изменение последовательности id БД. <br>
Возможные перемещения в такие папки как: login_error_accounts, temporary_ban_account. <br>
Перемещение в login_error_accounts произойдёт в том случае, если не смогли войти в аккаунт. <br>
Перемещение в temporary_ban_account произойдёт в том случае, если аккаунт получил временный бан. <br>

**Параметры:**<br>
- error (str): Полученная ошибка. <br>
- id_folder: (int): id папки у аккаунта с полученной ошибкой. <br>
- account_type: (str): тип аккаунта у которого получили ошибку.
Возможные принимаемые значения: active, archive, main, login_error, temporary_ban. <br><br>


**Функция "_change_folder": <br>**

**def _change_folder(id_folder: int,account_type: str, target_account_type: str):**

**Описание:<br>**
Копирует указанную папку в указанный тип аккаунтов. <br>
Пример: получили путь 'accounts/active_accounts/3'. 
Этот аккаунт будет перемещён в указанный тип аккаунтов (target_account_type) добавляя его последним id. <br>
Запоминаем этот id и в конце его вернём. <br>
То есть мы получили login_error, и в таком типе аккаунтов последний id это 5, значит аккаунт с ошибкой, 
будет добавлен с id = 6 (accounts/login_error_accounts/6). <br>
Удалит папку откуда скопировали, то есть 'accounts/active_accounts/3'.

Меняет последовательность id в папке с типом аккаунтов откуда получили аккаунт. <br>
Т.к. Удалён аккаунт откуда брали, значит необходимо восстановить последовательность id. 
Меняет id на минус один после папки которую получили из id_folder. <br>
Пример: есть последовательность с удалённым id = 3. Последовательность: 0 1 2 4 5.
Будут переименованы все папки начиная с 4. <br> 
Итог: 0 1 2 3 4

**Параметры:<br>**
- id_folder (int): id папки где произошла ошибка. <br>
- account_type (str): тип аккаунта где произошла ошибка.
Возможные принимаемые значения: active, archive, main, login_error, temporary_ban. <br>
- target_account_type (str): куда перемещать аккаунт.
Возможные принимаемые значения: login_error, temporary_ban.<br>

**Возвращаемое значение:**
- int: возвращает новый id который присвоили в перемещённую папку с необходимым типом аккаунтов.


**Функция "_change_db": <br>**

**def  _change_db(id: int,account_type: str, id_in_target_type: int, target_account_type: str, error_description_solution: list):**

**Описание:<br>**
Изменяет данные в БД. тоже самое что в функции "_change_folder"?, но только это всё происходит в БД<br>
Изменяет id и тип аккаунта на указанные (id_in_target_type, target_account_type). <br>
Изменяя аккаунт по отбору (id, account_type). <br>
Меняет последовательность id в БД откуда взяли аккаунт на минус одно значение, всё что идёт после полученного id. <br>

**Параметры:<br>**
- id (str): id папки с аккаунтом где произошла ошибка. <br>
- account_type (str): тип аккаунта где получили ошибку. 
Возможные принимаемые значения: active, archive, main, login_error, temporary_ban.<br>
- id_in_target_type (int): id который необходимо присвоить аккаунту. <br>
- target_account_type (str): тип аккаунта который необходимо присвоить.
Возможные принимаемые значения: login_error, temporary_ban.<br>

**Возвращаемое значение:**
- Нет

## Диалоговое окно при ошибке прокси для загрузки аккаунтов (error_proxy.py)

### Общее описание
Модуль `error_proxy.py` реализует диалоговое окно для обработки ошибок подключения к прокси-серверу при загрузке аккаунтов в разделе [`accounts.py`](#главный-раздел-аккаунтов-accountspy). Основные функции:
- Отображение текущих настроек прокси
- Возможность ввода новых параметров прокси
- Проверка работоспособности прокси через [`check_proxy`](#проверка-прокси-check_proxypy)
- Сохранение изменений в БД или отключение использования прокси

**Ключевые особенности:**
- Интеграция с таблицей `proxy` в БД [`data_base.sqlite3`](#бд)
- Валидация вводимых данных
- Использование [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для показа уведомлений
- Автоматическое определение пути к Qt plugins

### Класс `DialogErrorProxy(DialogErrorProxyUi)`
Наследуется от сгенерированного UI-класса `DialogErrorProxyUi`. Управляет интерфейсом обработки ошибок прокси.

#### **Конструктор:**
```python
def __init__(self, ip: str, port: str, login: str, password: str)
```
**Параметры:**
- `ip` - текущий IP прокси-сервера
- `port` - текущий порт прокси
- `login` - логин для аутентификации
- `password` - пароль для аутентификации

**Инициализирует:**
- Корневую директорию проекта (`self.root_project_dir = '..'`)
- Заполнение полей ввода текущими параметрами прокси
- Подключение обработчиков событий:
  - `pushButton_close` - закрытие окна
  - `pushButton_enter` - сохранение новых параметров прокси
  - `pushButton_not_use_proxy` - отключение использования прокси

#### **Методы:**

##### `show_info(self)`
**Описание:**  
Отображает информационное окно с сообщением об ошибке подключения к прокси.

**Логика работы:**
1. Создает экземпляр [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) с параметрами:
   - Заголовок: "Внимание!"
   - Текст: "При попытке подключиться к прокси\nпроизошла ошибка входа"
   - Звуковое уведомление: "notification.mp3"
2. Отображает модальное окно

##### `_enter_proxy(self)`
**Описание:**  
Сохраняет новые параметры прокси после проверки их работоспособности.

**Логика работы:**
1. Получает данные из полей ввода:
   - IP (`lineEdit_ip`)
   - Порт (`lineEdit_port`)
   - Логин (`lineEdit_login`)
   - Пароль (`lineEdit_password`)
2. Валидирует обязательные поля (IP и порт):
   - Подсвечивает пустые поля розовым цветом
   - Показывает сообщение об ошибке через [`DialogInfo`](#диалоговое-окно-с-информацией-infopy)
3. Проверяет прокси через [`check_proxy`](#проверка-прокси-check_proxypy)
4. При успешной проверке:
   - Сохраняет параметры в БД (таблица `proxy`)
   - Показывает сообщение об успехе
   - Закрывает окно
5. При ошибке показывает соответствующее сообщение

**Использует:**
- [`check_proxy`](#проверка-прокси-check_proxypy) для проверки подключения
- [`sqlite3`](#бд) для работы с БД
- [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для показа сообщений

##### `_not_use_proxy(self)`
**Описание:**  
Отключает использование прокси при загрузке аккаунтов.

**Логика работы:**
1. Устанавливает `use_proxy_to_enter = 0` в таблице `proxy` БД
2. Показывает информационное сообщение
3. Закрывает окно

**Использует:**
- [`sqlite3`](#бд) для работы с БД
- [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для показа сообщения

### Особенности реализации

1. **Работа с Qt:**
   - Автоматическое определение пути к Qt plugins через `Path(PyQt5.__file__)`
   - Проверка существования пути перед установкой
   - Установка переменной окружения `QT_QPA_PLATFORM_PLUGIN_PATH`

2. **Безопасность:**
   - Валидация обязательных полей перед проверкой прокси
   - Обработка ошибок подключения к БД
   - Явное закрытие соединений с БД

3. **UI/UX:**
   - Подсветка невалидных полей
   - Информативные сообщения об ошибках и успехах
   - Звуковые уведомления через "notification.mp3"

4. **Интеграция:**
   - Тесно связан с [`accounts.py`](#главный-раздел-аккаунтов-accountspy) для загрузки аккаунтов
   - Использует общие механизмы работы с БД и показа сообщений

### Пример использования
```python
# Создание и отображение окна
dialog = DialogErrorProxy('127.0.0.1', '1080', 'user', 'pass')
dialog.show_info()  # Показ сообщения об ошибке
dialog.exec_()      # Запуск модального окна
```

### Связи с другими модулями
- Использует [`check_proxy`](#проверка-прокси-check_proxypy) для проверки подключения
- Взаимодействует с таблицей `proxy` в БД [`data_base.sqlite3`](#бд)
- Использует [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для показа сообщений
- Интегрирован с процессом загрузки аккаунтов в [`accounts.py`](#главный-раздел-аккаунтов-accountspy)

# Диалоговое окно при ошибке прокси для работы с другими разделами (error_proxy_for_work.py)

## Общее описание
Модуль `error_proxy_for_work.py` реализует диалоговое окно для обработки ошибок подключения к прокси-серверу при работе с различными разделами программы (кроме раздела аккаунтов). Основные функции:

- Отображение текущих параметров прокси (IP, порт, логин, пароль)
- Возможность ввода новых параметров прокси
- Проверка работоспособности прокси через [`check_proxy`](#проверка-прокси-check_proxypy)
- Сохранение новых параметров в БД при успешной проверке
- Возможность продолжить работу без использования прокси

**Ключевые особенности:**
- Наследование от базового UI-класса `DialogErrorProxyUi`
- Интеграция с системой уведомлений через [`DialogInfo`](#диалоговое-окно-с-информацией-infopy)
- Автоматическое определение пути к Qt plugins
- Визуальное выделение незаполненных обязательных полей

## Класс `DialogErrorProxyForWork(DialogErrorProxyUi)`

### Конструктор
```python
def __init__(self, ip: str, port: str, login: str, password: str)
```

**Параметры:**
- `ip` (str) - текущий IP прокси-сервера
- `port` (str) - текущий порт прокси
- `login` (str) - текущий логин для аутентификации
- `password` (str) - текущий пароль для аутентификации

**Инициализирует:**
- Корневую директорию проекта (`self.root_project_dir = '..'`)
- Сохранение переданных параметров прокси
- Заполнение полей ввода текущими значениями
- Подключение обработчиков событий для кнопок:
  - `pushButton_close` - закрытие окна
  - `pushButton_enter` - проверка и сохранение новых параметров прокси
  - `pushButton_not_use_proxy` - закрытие окна (продолжение без прокси)
- Настройку пути к Qt plugins через:
  ```python
  qt_plugins_path = str(Path(PyQt5.__file__).parent / "Qt5" / "plugins")
  os.environ["QT_QPA_PLATFORM_PLUGIN_PATH"] = qt_plugins_path
  ```

### Методы

#### `show_info(self)`
**Описание:**  
Отображает информационное окно [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) с сообщением об ошибке подключения к прокси.

**Параметры окна:**
- Заголовок: "Внимание!"
- Текст: "При попытке подключиться к прокси\nпроизошла ошибка входа"
- Звуковое уведомление: "notification.mp3"

**Использует:**
- [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для показа сообщения
- Файл звукового уведомления из `/resources/sounds/`

#### `enter_proxy(self)`
**Описание:**  
Основной метод для проверки и сохранения новых параметров прокси. Выполняет:

1. Получение значений из полей ввода
2. Валидацию обязательных полей (IP и порт)
3. Проверку работоспособности прокси через [`check_proxy`](#проверка-прокси-check_proxypy)
4. Сохранение новых параметров в БД при успешной проверке
5. Отображение результатов операций

**Логика работы:**
1. Проверяет заполнение обязательных полей:
   - Если IP не указан, выделяет поле красным цветом
   - Если порт не указан, выделяет соответствующее поле
   - Показывает сообщение об ошибке через [`DialogInfo`](#диалоговое-окно-с-информацией-infopy)
2. При успешной проверке:
   - Обновляет запись в таблице `proxy` БД
   - Показывает сообщение об успехе с внешним IP
   - Закрывает окно
3. При ошибке проверки:
   - Показывает сообщение об ошибке подключения

**Использует:**
- [`check_proxy`](#проверка-прокси-check_proxypy) для проверки работоспособности прокси
- [`sqlite3`](#бд) для работы с базой данных
- [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для показа сообщений

### Особенности реализации

1. **Валидация полей:**
   - Визуальное выделение незаполненных обязательных полей (IP и порт)
   - Проверка перед вызовом функции проверки прокси

2. **Работа с БД:**
   - Обновление всех параметров прокси в одном запросе
   - Использование параметризованных запросов для безопасности

3. **Интеграция:**
   - Использует [`check_proxy`](#проверка-прокси-check_proxypy) для проверки подключения
   - Следует общему стилю показа сообщений через [`DialogInfo`](#диалоговое-окно-с-информацией-infopy)

4. **UI/UX:**
   - Четкое разделение обязательных и необязательных полей
   - Визуальная обратная связь при ошибках ввода
   - Звуковое уведомление при показе сообщений

### Пример использования
```python
# Создание и отображение окна с текущими параметрами прокси
dialog = DialogErrorProxyForWork('192.168.1.1', '1080', 'user', 'pass')
dialog.show_info()  # Показ сообщения об ошибке
dialog.exec_()      # Показ модального окна
```

### Связи с другими модулями
- Использует [`check_proxy`](#проверка-прокси-check_proxypy) для проверки прокси
- Взаимодействует с таблицей `proxy` в БД [`data_base.sqlite3`](#бд)
- Наследует UI-класс `DialogErrorProxyUi`, сгенерированный Qt Designer
- Использует [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для показа сообщений

## Отличия от аналогичного модуля для раздела аккаунтов
Данный модуль отличается от [`error_proxy.py`](#диалоговое-окно-при-ошибке-прокси-для-загрузки-аккаунтов-error_proxypy) следующим:
1. Не изменяет флаг `use_proxy_to_enter` в БД
2. Предоставляет кнопку для продолжения работы без прокси
3. Используется для всех разделов, кроме раздела аккаунтов

## Диалоговое окно с информацией (info.py)

### Общее описание
Модуль `info.py` реализует универсальное диалоговое окно для отображения информации пользователю в проекте Black SMM. Основные функции:
- Отображение текстовых сообщений с заголовком
- Поддержка звуковых уведомлений
- Простое закрытие по кнопке "ОК"
- Интеграция с системой звуковых уведомлений через `pygame`

**Ключевые особенности:**
- Автоматическая настройка пути к Qt plugins для корректной работы PyQt5
- Поддержка кастомного текста для кнопки подтверждения
- Проигрывание звуковых файлов из директории `/resources/sounds/`
- Наследование от UI-класса, сгенерированного Qt Designer

### Класс `DialogInfo(DialogInfoUi)`

#### Конструктор
```python
def __init__(self, title: str, text: str, file_sound: str = None, button_text: str = 'ОК')
```

**Параметры:**
- `title` (str) - заголовок окна
- `text` (str) - основной текст сообщения
- `file_sound` (str, optional) - имя звукового файла из `/resources/sounds/`
- `button_text` (str, optional) - текст кнопки (по умолчанию "ОК")

**Инициализирует:**
- Корневую директорию проекта (`self.root_project_dir = '..'`)
- Настройку пути к Qt plugins через:
  ```python
  qt_plugins_path = str(Path(PyQt5.__file__).parent / "Qt5" / "plugins")
  if not Path(qt_plugins_path).exists():
      raise RuntimeError(f"Qt plugins not found at: {qt_plugins_path}")
  os.environ["QT_QPA_PLATFORM_PLUGIN_PATH"] = qt_plugins_path
  ```
- Подключение обработчиков событий для кнопок
- Установку переданных текстов в UI-элементы:
  - `label_titel` - заголовок
  - `label_info` - основной текст
  - `pushButton_ok` - текст кнопки

#### Методы

##### Обработка звукового уведомления
При наличии параметра `file_sound`:
1. Формирует полный путь к файлу: `../resources/sounds/{file_sound}`
2. Инициализирует `pygame.mixer`
3. Загружает и воспроизводит звуковой файл
4. Ошибки воспроизведения игнорируются (блок `try-except`)

**Использует:**
- Библиотеку [`pygame`]() для работы со звуком
- Файлы из директории `/resources/sounds/`

##### Обработчики событий
- `pushButton_close.clicked` - закрытие окна
- `pushButton_ok.clicked` - закрытие окна

### Особенности реализации

1. **Работа с Qt:**
   - Автоматическое определение пути к Qt plugins
   - Проверка существования пути перед установкой
   - Установка переменной окружения `QT_QPA_PLATFORM_PLUGIN_PATH`

2. **Безопасность:**
   - Обработка ошибок при работе со звуковыми файлами
   - Проверка существования Qt plugins path

3. **UI/UX:**
   - Единообразный стиль информационных окон
   - Поддержка звуковых уведомлений
   - Возможность кастомизации текста кнопки

4. **Интеграция:**
   - Используется во всех модулях проекта для показа сообщений
   - Наследует UI-класс `DialogInfoUi` из `app/general/ui/dialog_info.py`

### Пример использования
```python
# Простое сообщение
dialog = DialogInfo("Внимание", "Произошла ошибка")
dialog.exec_()

# Сообщение со звуком и кастомной кнопкой
dialog = DialogInfo(
    "Успех", 
    "Операция завершена", 
    "success.mp3", 
    "Закрыть"
)
dialog.exec_()
```

### Связи с другими модулями
- Наследует UI-класс [`DialogInfoUi`]()
- Используется во всех основных модулях проекта для показа сообщений:
  - [`accounts.py`](#главный-раздел-аккаунтов-accountspy)
  - [`proxy.py`](#главный-раздел-proxypy-)
  - [`error_handler.py`](#обработчик-ошибок-error_handlerpy)
  - И других

# Диалоговое окно с выбором "ок или отмена" (ok_or_cancel.py)

## Общее описание
Модуль `ok_or_cancel.py` реализует универсальное диалоговое окно с выбором действия ("ОК" или "Отмена"). Основные функции:
- Отображение заголовка и текста сообщения
- Воспроизведение звукового уведомления (опционально)
- Возврат результата выбора пользователя через сигнал `data_returned`
- Интеграция с системой звуковых уведомлений через [`pygame`]()

**Ключевые особенности:**
- Наследование от базового UI-класса `DialogOkOrCancelUi`
- Поддержка Qt plugins path для корректной работы PyQt5
- Использование сигналов PyQt5 для передачи данных
- Гибкая настройка через параметры конструктора

## Класс `DialogOkOrCancel(DialogOkOrCancelUi)`

### Конструктор
```python
def __init__(self, title: str, text: str, sound_file: str = None)
```

**Параметры:**
- `title` (str) - заголовок окна
- `text` (str) - основной текст сообщения
- `sound_file` (str, optional) - имя звукового файла из `/resources/sounds/` (например, "notification.mp3")

**Инициализирует:**
- Корневую директорию проекта (`self.root_project_dir = '..'`)
- Сохранение переданных параметров (`self.title`, `self.text`, `self.sound_file`)
- Настройку Qt plugins path через:
  ```python
  qt_plugins_path = str(Path(PyQt5.__file__).parent / "Qt5" / "plugins")
  os.environ["QT_QPA_PLATFORM_PLUGIN_PATH"] = qt_plugins_path
  ```
- Подключение обработчиков событий для кнопок:
  - `pushButton_close` - закрытие с результатом `False`
  - `pushButton_cancel` - закрытие с результатом `False` 
  - `pushButton_ok` - закрытие с результатом `True`
- Установку текста в элементы интерфейса:
  - `label_title.setText(self.title)`
  - `label_info.setText(self.text)`
- Воспроизведение звука (если указан) через [`pygame.mixer`]()

### Сигналы
```python
data_returned = pyqtSignal(bool)
```
Отправляет `True` если пользователь нажал "ОК", `False` если "Отмена" или закрыл окно.

### Методы

#### `result_true(self)`
**Описание:**  
Обработчик нажатия кнопки "ОК". Отправляет `True` через сигнал `data_returned` и закрывает окно.

**Логика работы:**
1. Вызывает `self.data_returned.emit(True)`
2. Закрывает окно через `self.close()`

#### `result_false(self)`
**Описание:**  
Обработчик нажатия кнопки "Отмена" или закрытия окна. Отправляет `False` через сигнал `data_returned` и закрывает окно.

**Логика работы:**
1. Вызывает `self.data_returned.emit(False)`
2. Закрывает окно через `self.close()`

#### Воспроизведение звука
**Описание:**  
При наличии параметра `sound_file` пытается воспроизвести звук из `/resources/sounds/`.

**Логика работы:**
1. Формирует путь к файлу:  
   ```python 
   sound_file_path = (self.root_project_dir + f"/sounds/{self.sound_file}")
   ```
2. Инициализирует [`pygame.mixer`]()
3. Загружает и воспроизводит звук:
   ```python
   pygame.mixer.music.load(sound_file_path)
   pygame.mixer.music.play()
   ```
4. Игнорирует любые ошибки воспроизведения (`try-except`)

### Особенности реализации

1. **Работа с Qt:**
   - Автоматическое определение пути к Qt plugins
   - Проверка существования пути перед установкой
   - Установка переменной окружения `QT_QPA_PLATFORM_PLUGIN_PATH`

2. **Безопасность:**
   - Обработка ошибок при воспроизведении звука
   - Гарантированное закрытие окна при любом исходе

3. **UI/UX:**
   - Четкое разделение кнопок подтверждения/отмены
   - Поддержка звуковых уведомлений
   - Единообразное оформление заголовка и текста

4. **Интеграция:**
   - Использует [`pygame`]() для работы со звуком
   - Наследует UI-класс `DialogOkOrCancelUi`

### Пример использования
```python
# Создание диалога
dialog = DialogOkOrCancel(
    title="Подтверждение", 
    text="Вы уверены, что хотите выполнить это действие?",
    sound_file="notification.mp3"
)

# Подключение обработчика результата
dialog.data_returned.connect(lambda result: print(f"User selected: {result}"))

# Показ модального окна
dialog.exec_()
```

### Связи с другими модулями
- Наследует UI-класс [`DialogOkOrCancelUi`]()
- Использует [`pygame`]() для воспроизведения звуков
- Интегрируется с другими модулями через сигнал `data_returned`


# Диалоговое окно с выбором "да или отмена" (yes_or_cancel.py)

## Общее описание
Модуль `yes_or_cancel.py` реализует универсальное диалоговое окно для получения подтверждения от пользователя с вариантами "Да" или "Отмена". Основные функции:
- Отображение текстового сообщения с заголовком
- Поддержка звуковых уведомлений (опционально)
- Возврат результата выбора пользователя через сигнал `data_returned`
- Интеграция с системой звуковых уведомлений через [`pygame`]()
- Автоматическая настройка пути к Qt plugins для корректной работы PyQt5

**Ключевые особенности:**
- Наследование от UI-класса `DialogYesOrCancelUi`, сгенерированного Qt Designer
- Использование сигналов PyQt5 для передачи данных между окнами
- Поддержка кастомного текста для кнопок
- Гибкая настройка через параметры конструктора

## Класс `DialogYesOrCancel(DialogYesOrCancelUi)`

### Конструктор
```python
def __init__(self, title: str, text: str, sound_file: str = None)
```

**Параметры:**
- `title` (str) - заголовок окна
- `text` (str) - основной текст сообщения
- `sound_file` (str, optional) - имя звукового файла из `/resources/sounds/` (например, "notification.mp3")

**Инициализирует:**
- Корневую директорию проекта (`self.root_project_dir = '..'`)
- Сохранение переданных параметров (`self.title`, `self.text`, `self.sound_file`)
- Настройку Qt plugins path через:
  ```python
  qt_plugins_path = str(Path(PyQt5.__file__).parent / "Qt5" / "plugins")
  os.environ["QT_QPA_PLATFORM_PLUGIN_PATH"] = qt_plugins_path
  ```
- Подключение обработчиков событий для кнопок:
  - `pushButton_close` - закрытие с результатом `False`
  - `pushButton_cancel` - закрытие с результатом `False`
  - `pushButton_ok` - закрытие с результатом `True`
- Установку текста в элементы интерфейса:
  - `label_title.setText(self.title)`
  - `label_info.setText(self.text)`
- Воспроизведение звука (если указан) через [`pygame.mixer`]()

### Сигналы
```python
data_returned = pyqtSignal(bool)
```
Отправляет:
- `True` - если пользователь нажал "Да"
- `False` - если пользователь нажал "Отмена" или закрыл окно

### Методы

#### `result_true(self)`
**Описание:**  
Обработчик нажатия кнопки "Да". Отправляет `True` через сигнал `data_returned` и закрывает окно.

**Логика работы:**
1. Вызывает `self.data_returned.emit(True)`
2. Закрывает окно через `self.close()`

#### `result_false(self)`
**Описание:**  
Обработчик нажатия кнопки "Отмена" или закрытия окна. Отправляет `False` через сигнал `data_returned` и закрывает окно.

**Логика работы:**
1. Вызывает `self.data_returned.emit(False)`
2. Закрывает окно через `self.close()`

#### Воспроизведение звука
**Описание:**  
При наличии параметра `sound_file` пытается воспроизвести звук из `/resources/sounds/`.

**Логика работы:**
1. Формирует путь к файлу:  
   ```python 
   sound_file_path = (self.root_project_dir + f"/sounds/{self.sound_file}")
   ```
2. Инициализирует [`pygame.mixer`]()
3. Загружает и воспроизводит звук:
   ```python
   pygame.mixer.music.load(sound_file_path)
   pygame.mixer.music.play()
   ```
4. Игнорирует любые ошибки воспроизведения (`try-except`)

### Особенности реализации

1. **Работа с Qt:**
   - Автоматическое определение пути к Qt plugins
   - Проверка существования пути перед установкой
   - Установка переменной окружения `QT_QPA_PLATFORM_PLUGIN_PATH`

2. **Безопасность:**
   - Обработка ошибок при воспроизведении звука
   - Гарантированное закрытие окна при любом исходе

3. **UI/UX:**
   - Четкое разделение кнопок подтверждения/отмены
   - Поддержка звуковых уведомлений
   - Единообразное оформление заголовка и текста

4. **Интеграция:**
   - Использует [`pygame`]() для работы со звуком
   - Наследует UI-класс `DialogYesOrCancelUi`

### Пример использования
```python
# Создание диалога
dialog = DialogYesOrCancel(
    title="Подтверждение", 
    text="Вы уверены, что хотите выполнить это действие?",
    sound_file="notification.mp3"
)

# Подключение обработчика результата
dialog.data_returned.connect(lambda result: print(f"User selected: {result}"))

# Показ модального окна
dialog.exec_()
```

### Связи с другими модулями
- Наследует UI-класс [`DialogYesOrCancelUi`]()
- Использует [`pygame`]() для воспроизведения звуков
- Интегрируется с другими модулями через сигнал `data_returned`


# Проверка HTML разметки (check_html_parse.py)

## Общее описание
Модуль `check_html_parse.py` предоставляет функционал для валидации HTML-разметки текста перед использованием в Telegram. Основные возможности:
- Проверка корректности вложенности и закрытия тегов
- Валидация допустимых тегов согласно спецификации Telegram
- Проверка обязательных атрибутов для тегов (например, `href` для `<a>`)
- Поддержка как ручной проверки через регулярные выражения, так и автоматической через [`BeautifulSoup`]()

**Ключевые особенности:**
- Двойная проверка (регулярные выражения + BeautifulSoup) для максимальной надежности
- Поддержка только тегов, разрешенных Telegram
- Четкое соответствие требованиям Telegram API к форматированию сообщений
- Быстрая обработка благодаря оптимизированным алгоритмам

## Импортируемые модули
- [`BeautifulSoup`]() из `bs4` - для парсинга и анализа HTML-структуры
- [`re`]() - для работы с регулярными выражениями при первичной проверке тегов

## Функции

### `check_html_parse(text: str) -> bool`
**Описание:**  
Проверяет, соответствует ли HTML-разметка в тексте требованиям Telegram. Возвращает `True` если разметка корректна, `False` если обнаружены ошибки.

**Параметры:**
- `text` (str): Текст с HTML-разметкой для проверки

**Возвращаемое значение:**
- `bool`: Результат проверки (`True` - валидно, `False` - невалидно)

**Логика работы:**
1. **Определение допустимых тегов** через константу `ALLOWED_TAGS`:
   ```python
   ALLOWED_TAGS = {"b", "i", "u", "s", "a", "code", "pre"}
   ```
   Соответствует [официальной спецификации Telegram](https://core.telegram.org/bots/api#html-style).

2. **Первичная проверка через регулярные выражения**:
   - Поиск всех тегов через `re.finditer()`
   - Проверка корректности вложенности через стек:
     - Для открывающего тега (`<tag>`) - добавление в стек
     - Для закрывающего тега (`</tag>`) - проверка соответствия последнему открытому тегу
   - Проверка, что все теги разрешены (`tag_name in ALLOWED_TAGS`)

3. **Дополнительная проверка через BeautifulSoup**:
   - Парсинг всего текста
   - Проверка:
     - Всех тегов на принадлежность к `ALLOWED_TAGS`
     - Наличия обязательного атрибута `href` для тега `<a>`
   - Обработка возможных исключений парсера

**Пример использования:**
```python
valid_html = "<b>Hello</b> <a href='https://example.com'>world</a>"
invalid_html = "<div>Not allowed</div>"

print(check_html_parse(valid_html))   # True
print(check_html_parse(invalid_html)) # False
```

**Обрабатываемые ошибки:**
1. Неразрешенные теги (не из `ALLOWED_TAGS`)
2. Незакрытые теги
3. Неправильная вложенность тегов
4. Отсутствие обязательных атрибутов
5. Некорректный синтаксис HTML

## Особенности реализации

1. **Двойная проверка**:
   - Быстрая предварительная проверка через регулярные выражения
   - Точная окончательная проверка через BeautifulSoup

2. **Производительность**:
   - Регулярные выражения обрабатывают текст за один проход
   - Стек для проверки вложенности работает за O(n)

3. **Безопасность**:
   - Гарантированная обработка всех возможных HTML-структур
   - Защита от "мусорных" тегов и атрибутов

4. **Совместимость**:
   - Точно соответствует требованиям Telegram
   - Поддерживает все официально разрешенные теги

## Интеграция с другими модулями
Модуль используется в:
- [`mailing_by_users.py`](#раздел-рассылка-по-юзерам-mailing_by_userspy) - для проверки HTML в сообщениях рассылки
- [`first_message_for_group.py`](#диалоговое-окно-с-первым-сообщением-в-канал-first_message_for_grouppy) - при настройке первого сообщения в канале

## Ограничения
- Не проверяет максимальную длину текста (ограничения Telegram)
- Не валидирует содержимое атрибутов (кроме наличия `href` для `<a>`)
- Поддерживает только теги, разрешенные в Telegram

## Пример полного использования
```python
from check_html_parse import check_html_parse

# Проверка допустимой разметки
valid = check_html_parse("<b>Жирный</b> и <i>курсивный</i> текст")
print(valid)  # True

# Проверка недопустимой разметки
invalid = check_html_parse("<script>alert('XSS')</script>")
print(invalid)  # False
```


# Главный раздел аккаунтов (accounts.py)

## Общее описание
Модуль `accounts.py` является центральным компонентом системы управления Telegram-аккаунтами в проекте Black SMM. Он предоставляет:

1. **Интерфейс** для просмотра и управления аккаунтами разных типов:
   - Активные (`active_accounts`)
   - Архивные (`archive_accounts`)
   - Главные (`main_accounts`)
   - Временно заблокированные (`temporary_ban_accounts`)
   - С ошибками входа (`login_error_accounts`)

2. **Функционал** для:
   - Отображения списка аккаунтов с детальной информацией
   - Добавления новых аккаунтов через tdata/session
   - Входа в аккаунты через Telegram Desktop
   - Управления статусами аккаунтов (перемещение между типами)
   - Удаления аккаунтов
   - Экспорта tdata

3. **Интеграцию** с:
   - Базой данных SQLite ([`data_base.sqlite3`](#бд))
   - Системой прокси ([`check_proxy`](#проверка-прокси-check_proxypy))
   - Механизмом обработки ошибок ([`error_handler`](#обработчик-ошибок-error_handlerpy))

## Классы

### `show_account(QThread)`
Поток для асинхронного получения информации об аккаунте Telegram.

**Конструктор:**
```python
def __init__(
    self,
    folder_path_account: str,  # Путь к папке аккаунта (с tdata)
    id_account: int,           # Уникальный ID аккаунта
    account_type: str,         # Тип аккаунта ('active', 'archive' и т.д.)
    use_proxy: bool,           # Флаг использования прокси
    id_proxy: str,             # IP прокси-сервера
    port: int,                 # Порт прокси
    login: str,                # Логин прокси
    password: str              # Пароль прокси
)
```

**Методы:**
- `run()` - Точка входа потока, запускает асинхронную задачу
- `async get_info_account()` - Основная логика получения данных:
  - Подключение через tdata с использованием [`TDesktop`]()
  - Конвертация в Telethon сессию
  - Получение данных аккаунта (`get_me()`)
  - Определение страны по номеру через [`get_country_flag`](#получение-geo-по-номеру-flagpy)
  - Обработка ошибок подключения

**Сигналы:**
```python
task_done = pyqtSignal(list, bool)
```
Возвращает:
1. Данные аккаунта или информацию об ошибке
2. Флаг наличия ошибки

### `WindowAccounts(WindowAccountsUi)`
Главное окно управления аккаунтами, наследуется от сгенерированного UI.

**Конструктор:**
```python
def __init__(self, switch_window=None)
```
- `switch_window` - функция для переключения между окнами программы

**Ключевые атрибуты:**
- `open_account` - Флаг активности загрузки аккаунтов
- `selected_account_type` - Текущий тип отображаемых аккаунтов
- `accounts`/`error_accounts` - Списки успешных/ошибочных подключений
- `active_threads` - Список активных потоков получения данных

## Основные методы

### `start_show_account(type_accounts: str)`
Инициирует процесс отображения аккаунтов указанного типа.

**Логика работы:**
1. Проверяет настройки прокси через [`check_proxy`](#проверка-прокси-check_proxypy)
2. Для каждого аккаунта создает поток `show_account`
3. Подключает обработчик `_show_account_done`
4. Управляет визуальными элементами прогресса

**Особенности:**
- Для `login_error` загружает данные напрямую из БД
- Автоматически обрабатывает ошибки прокси через [`DialogErrorProxy`](#диалоговое-окно-при-ошибке-прокси-для-загрузки-аккаунтов-error_proxypy)

### `_show_account_done(account_data: list, account_error: bool)`
Обрабатывает результаты работы потока `show_account`.

**Логика работы:**
1. Сортирует аккаунты по ID
2. Обновляет данные в БД через `_update_account_data`
3. Получает дополнительную информацию через `_get_additional_information`
4. Заполняет таблицу `tableWidget_account`:
   - ID, юзернейм, имя, телефон
   - Флаг страны (из [`resources/pictures_flag`]())
   - Время с момента добавления
   - Примечания (редактируемое поле)
5. Обрабатывает ошибки через [`error_handler`](#обработчик-ошибок-error_handlerpy)

### `_add_accounts()`
Запускает процесс добавления новых аккаунтов через:
1. [`DialogInfoAddAccounts`](#информация-о-добавлении-аккаунтов-info_add_accountspy) - информационное окно
2. [`DialogAddAccounts`](#добавление-новых-аккаунтов-add_accountspy) - основной интерфейс добавления

### `_move_accounts(button: QPushButton)`
Перемещает выбранные аккаунты между типами (активные/архив/главные).

**Логика работы:**
1. Копирует папки аккаунтов в целевую директорию
2. Обновляет записи в БД
3. Восстанавливает последовательность ID в исходной папке
4. Обновляет интерфейс через `show_accounts_from_db`

### `_enter_account()`
Обеспечивает вход в выбранный аккаунт через Telegram Desktop.

**Логика работы:**
1. Копирует tdata в `/Telegram Desktop/`
2. Запускает `Telegram.exe`
3. Обрабатывает ошибки доступа к файлам

### `_delete_accounts()`
Удаляет выбранные аккаунты после подтверждения через [`DialogYesOrCancel`](#диалоговое-окно-с-выбором-да-или-отмена-yes_or_cancelpy).

**Особенности:**
- Полностью удаляет папку аккаунта
- Обновляет последовательность ID оставшихся аккаунтов
- Удаляет запись из БД

## Вспомогательные методы

### `_update_account_data(account_data: dict)`
Сравнивает данные аккаунта с БД и обновляет при расхождениях.

**Поля для сравнения:**
- ID Telegram
- Юзернейм
- Имя
- Номер телефона

### `_get_additional_information(account_data: list) -> list`
Получает из БД дополнительную информацию:
- Время с момента добавления (в днях)
- Дата последнего использования
- Примечания

### `show_accounts_from_db()`
Отображает аккаунты текущего типа напрямую из БД, минуя подключение к Telegram.

**Используется для:**
- Аккаунтов с ошибками входа
- Быстрого обновления списка

## Особенности реализации

1. **Работа с прокси:**
   - Сохранение оригинального socket (`self.original_socket`)
   - Автоматическое восстановление после операций
   - Интеграция с [`check_proxy`](#проверка-прокси-check_proxypy)

2. **Потокобезопасность:**
   - Управление списком активных потоков (`self.active_threads`)
   - Ожидание завершения всех потоков перед обновлением UI

3. **Обработка ошибок:**
   - Централизованная обработка через [`error_handler`](#обработчик-ошибок-error_handlerpy)
   - Перемещение проблемных аккаунтов в соответствующие папки

4. **Интеграция с БД:**
   - Хранение полной информации об аккаунтах
   - Автоматическое обновление при изменениях
   - Синхронизация с файловой структурой

5. **UI/UX:**
   - Анимация загрузки (`_fading_progress_bar`)
   - Редактируемые примечания с автосохранением
   - Визуализация статусов (иконки, цвета)

## Пример использования

```python
# Создание окна
window = WindowAccounts(switch_window_function)

# Отображение активных аккаунтов
window.start_show_account('active')

# Добавление обработчиков
window.pushButton_add.clicked.connect(lambda: window._add_accounts())
window.pushButton_delete.clicked.connect(lambda: window._delete_accounts())
```

## Связи с другими модулями

- Использует [`flag.py`](#получение-geo-по-номеру-flagpy) для определения страны
- Интегрирован с [`error_handler.py`](#обработчик-ошибок-error_handlerpy) для обработки ошибок
- Взаимодействует с [`Dialog`]() классами для пользовательских взаимодействий
- Хранит данные в [`data_base.sqlite3`](#бд)

  
## Добавление новых аккаунтов (add_accounts.py)

### Общее описание
Модуль `add_accounts.py` реализует функционал добавления новых Telegram-аккаунтов в программу через папки `tdata` или архивы. Основные возможности:
- Поддержка различных форматов архивов (ZIP, RAR, TAR, 7Z)
- Автоматическая проверка и валидация данных аккаунта
- Интеграция с системой автозаполнения профиля
- Обработка ошибок входа и дубликатов аккаунтов
- Работа через прокси (SOCKS5)

**Ключевые особенности:**
- Многопоточная архитектура через `QThread`
- Поддержка как папок с `tdata`, так и архивов
- Интеграция с основной БД проекта (`data_base.sqlite3`)
- Автоматическая очистка временных файлов

### Классы

#### `AddAccounts(QThread)`
Поток для обработки и добавления одного аккаунта. Наследуется от `QThread`.

**Конструктор:**
```python
def __init__(self, path: str, this_folder: bool, use_proxy: bool, 
             id_proxy: str, port: int, login: str, password: str)
```
**Параметры:**
- `path` - Путь к папке/архиву с аккаунтом
- `this_folder` - Флаг, указывающий на папку (True) или архив (False)
- `use_proxy` - Флаг использования прокси
- `id_proxy`, `port`, `login`, `password` - Данные прокси

**Сигналы:**
```python
task_done = pyqtSignal(list, bool, str, bool)
```
Возвращает:
1. Данные аккаунта или пустой список
2. Флаг успешного добавления
3. TG ID существующего аккаунта (или '0')
4. Флаг ошибки входа

**Методы:**

##### `run()`
Точка входа потока. Определяет тип источника (папка/архив) и запускает соответствующий метод.

##### `viewing_folder_in_path(path: str)`
Проверяет наличие папки `tdata` в указанном пути и запускает проверку аккаунта.

##### `viewing_folder_in_path_archive(archive_path: str)`
Распаковывает архив и ищет папку `tdata` для последующей обработки. Поддерживает форматы:
- ZIP через [`zipfile`]()
- RAR через [`rarfile`]()
- TAR через [`tarfile`]()
- 7Z через [`py7zr`]()

##### `async check_account(folder_path_account: str, path_in_tdata: str)`
Основная логика проверки и добавления аккаунта:
1. Подключение через [`TDesktop`]() и конвертация в Telethon сессию
2. Проверка на дубликаты в БД
3. Автозаполнение профиля (если настроено):
   - Аватар из `/resources/autofill/avatar_picture/`
   - Имя и фамилия из БД `autofill_data`
   - Генерация случайного username
   - Установка описания (bio)
4. Обработка ошибок через [`error_handler`](#обработчик-ошибок-error_handlerpy)

##### `async quit_async()`
Асинхронное завершение потока с гарантированным отключением клиента.

#### `DialogAddAccounts(DialogAddAccountsUi)`
Главное диалоговое окно для управления процессом добавления аккаунтов. Наследуется от сгенерированного UI.

**Конструктор:**
```python
def __init__(self, path: str)
```
**Атрибуты:**
- `active_threads` - Список активных потоков
- `original_socket` - Оригинальный socket до изменения прокси
- Статистические переменные (`quantity_start_accounts`, `successful_additions` и др.)
- `data_accounts` - Список успешно добавленных аккаунтов

**Методы:**

##### `start()`
Инициирует процесс добавления:
1. Проверка наличия папок/архивов
2. Проверка прокси через [`check_proxy`](#проверка-прокси-check_proxypy)
3. Запуск потоков `AddAccounts` для каждого источника

##### `add_account_done(data_account: list, success: bool, existing_account: str, error_enter: bool)`
Обработчик завершения работы потока:
1. Обновление статистики
2. Копирование валидных аккаунтов в `active_accounts`
3. Обновление БД
4. Отображение результатов

##### `open_report()`
Показывает окно [`DialogErrorAddAccounts`](#ошибка-при-добавлении-нового-аккаунта-error_add_accountspy) с дубликатами аккаунтов.

##### `selecting_folder_save()`
Позволяет сохранить аккаунты с ошибками входа в указанную папку.

##### `def_close()` и `def_close_2()`
Обработчики закрытия окна с подтверждением через [`DialogYesOrCancel`](#диалоговое-окно-с-выбором-да-или-отмена-yes_or_cancelpy).

### Логика работы

1. **Подготовка:**
   - Очистка временных файлов (`error_enter_accounts`, `test_account`)
   - Проверка прокси через [`check_proxy`](#проверка-прокси-check_proxypy)
   - Подсчет источников для прогресс-бара

2. **Обработка:**
   - Для каждого источника создается поток `AddAccounts`
   - Поток определяет тип источника (папка/архив)
   - Ищет папку `tdata` и проверяет аккаунт
   - При успехе - добавляет в БД, при ошибке - логирует

3. **Завершение:**
   - Копирование валидных аккаунтов в `active_accounts`
   - Обновление БД
   - Отображение статистики через [`DialogInfo`](#диалоговое-окно-с-информацией-infopy)
   - Очистка временных файлов

### Особенности реализации

1. **Работа с файлами:**
   - Автоматическая очистка временных файлов в деструкторе
   - Поддержка вложенных архивов
   - Обработка конфликтов имен при копировании

2. **Безопасность:**
   - Восстановление оригинального socket после операций
   - Гарантированное освобождение ресурсов
   - Обработка исключений при работе с файлами

3. **Интеграция:**
   - Использует [`check_proxy`](#проверка-прокси-check_proxypy) для проверки прокси
   - Взаимодействует с [`DialogErrorProxy`](#диалоговое-окно-при-ошибке-прокси-для-загрузки-аккаунтов-error_proxypy) при ошибках
   - Сохраняет данные в таблицу `accounts` БД

4. **Производительность:**
   - Многопоточная обработка аккаунтов
   - Прогресс-бар с реальным отображением состояния

### Пример использования
```python
# Создание и запуск диалога
dialog = DialogAddAccounts(path_to_accounts)
dialog.start()
dialog.exec_()
```

### Связи с другими модулями
- Использует [`check_proxy`](#проверка-прокси-check_proxypy) для проверки прокси
- Показывает ошибки через [`DialogErrorProxy`](#диалоговое-окно-при-ошибке-прокси-для-загрузки-аккаунтов-error_proxypy)
- Взаимодействует с БД через `sqlite3`
- Использует [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для уведомлений

# Ошибка при добавлении нового аккаунта (error_add_accounts.py)

## Общее описание
Модуль `error_add_accounts.py` реализует диалоговое окно для отображения информации об аккаунтах, которые уже существуют в программе, при попытке их повторного добавления. Основные функции:

- Отображение списка существующих аккаунтов по их Telegram ID
- Показ детальной информации о каждом аккаунте (ID, Telegram ID, username, статус)
- Перевод статусов аккаунтов на русский язык для удобства восприятия

**Ключевые особенности:**
- Интеграция с основной БД проекта (`data_base.sqlite3`)
- Использование Qt для отображения данных в табличном виде
- Автоматическое удаление дубликатов Telegram ID из входного списка
- Центрирование текста и запрет на редактирование ячеек таблицы

## Класс `DialogErrorAddAccounts(DialogErrorAddAccountsUi)`

### Конструктор
```python
def __init__(self, list_tg_id: list)
```

**Параметры:**
- `list_tg_id` (list) - список Telegram ID аккаунтов, которые уже существуют в программе  
  Пример: `[7352730490, 7612581345]`

**Инициализирует:**
- Корневую директорию проекта (`self.root_project_dir = '..'`)
- Очистку входного списка от дубликатов через `list(set(list_tg_id))`
- Подключение обработчика события для кнопки закрытия окна
- Вызов метода `add_rows()` для заполнения таблицы данными

### Методы

#### `add_rows(self, list_tg_id: list)`
**Описание:**  
Заполняет таблицу `tableWidget_account` данными о существующих аккаунтах, полученными из БД.

**Логика работы:**
1. Подключается к БД (`data_base.sqlite3`) в директории `working_files`
2. Для каждого Telegram ID в списке:
   - Выполняет SQL-запрос:
     ```python
     cursor.execute(
         "SELECT id, id_tg, user_name, account_status FROM accounts WHERE id_tg = ?", 
         (tg_id,)
     )
     ```
   - Добавляет новую строку в таблицу
   - Для каждого поля в результате запроса:
     - Создает элемент таблицы `QTableWidgetItem`
     - Если это поле статуса (индекс 3), переводит его на русский язык:
       - `active` → "Активный"
       - `archive` → "В архиве" 
       - `main` → "Главный"
       - `temporary_ban` → "Во временном бане"
       - `login_error` → "С ошибкой входа"
     - Настраивает внешний вид элемента:
       - Центрирование текста (`Qt.AlignCenter`)
       - Размер шрифта (9 пунктов)
       - Запрет на редактирование (`~Qt.ItemIsEditable`)
3. Закрывает соединение с БД

**Использует:**
- [`sqlite3`](#бд) для работы с базой данных
- `PyQt5.QtWidgets.QTableWidgetItem` для создания элементов таблицы
- `PyQt5.QtCore.Qt` для настроек выравнивания и флагов

### Особенности реализации

1. **Работа с данными:**
   - Автоматическое удаление дубликатов Telegram ID через преобразование в множество
   - Перевод статусов аккаунтов для удобства пользователя
   - Центрирование содержимого всех ячеек таблицы

2. **Безопасность:**
   - Явное закрытие соединения с БД после использования
   - Защита от SQL-инъекций через параметризованные запросы

3. **UI/UX:**
   - Единообразное оформление всех ячеек таблицы
   - Запрет на редактирование данных напрямую в таблице
   - Четкое структурирование информации

4. **Производительность:**
   - Минимизация запросов к БД (один запрос на аккаунт)
   - Оптимизированное заполнение таблицы

### Пример использования
```python
# Создание и отображение окна с списком существующих аккаунтов
existing_accounts = [7352730490, 7612581345]
dialog = DialogErrorAddAccounts(existing_accounts)
dialog.exec_()  # Показ модального окна
```

### Связи с другими модулями
- Используется в [`add_accounts.py`](#добавление-новых-аккаунтов-add_accountspy) для показа дубликатов аккаунтов
- Взаимодействует с таблицей `accounts` в БД [`data_base.sqlite3`](#бд)
- Наследует UI-класс `DialogErrorAddAccountsUi`, сгенерированный Qt Designer


## Ошибка открытия аккаунта при добавлении нового аккаунта (error_open_accounts.py)

### Общее описание
Модуль `error_open_accounts.py` реализует диалоговое окно для отображения информации об аккаунтах, при открытии которых произошли ошибки во время их добавления в программу. Основные функции:

- Отображение списка аккаунтов с ошибками входа
- Показ детальной информации о каждой ошибке (тип ошибки и рекомендуемое решение)
- Центрирование текста в таблице и разрешение редактирования только поля с решением
- Интеграция с системой уведомлений через [`DialogInfo`](#диалоговое-окно-с-информацией-infopy)

**Ключевые особенности:**
- Наследование от базового класса `DialogErrorAddAccountsUi`
- Использование Qt для отображения данных в табличном виде (`QTableWidget`)
- Автоматическая настройка пути к Qt plugins
- Проигрывание звукового уведомления при показе информации

### Класс `DialogErrorOpenAccounts(DialogErrorAddAccountsUi)`

#### Конструктор
```python
def __init__(self, accounts: list)
```
**Параметры:**
- `accounts` (list) - список аккаунтов с ошибками в формате:
  ```python
  [
      [id_tg, user_name, error_description, solution],
      ...
  ]
  ```

**Инициализирует:**
- Список аккаунтов (`self.accounts = accounts`)
- Настройку пути к Qt plugins через:
  ```python
  qt_plugins_path = str(Path(PyQt5.__file__).parent / "Qt5" / "plugins")
  os.environ["QT_QPA_PLATFORM_PLUGIN_PATH"] = qt_plugins_path
  ```
- Вызов методов:
  - `show_accounts()` - заполнение таблицы данными
  - `show_info()` - показ информационного сообщения
- Подключение обработчика для кнопки закрытия (`pushButton_close.clicked.connect(self.close)`)

#### Методы

##### `show_accounts(self)`
**Описание:**  
Заполняет таблицу `tableWidget_account` данными об аккаунтах с ошибками.

**Логика работы:**
1. Очищает таблицу (`setRowCount(0)`)
2. Для каждого аккаунта:
   - Добавляет новую строку (`insertRow(counter)`)
   - Заполняет колонки:
     - № строки (нередактируемое)
     - Telegram ID (нередактируемое)
     - Username (нередактируемое)
     - Описание ошибки (нередактируемое)
     - Решение (редактируемое)
3. Настраивает внешний вид ячеек:
   - Центрирование текста (`Qt.AlignCenter`)
   - Размер шрифта (9 пунктов)
   - Разрешение редактирования только последней колонки (`Qt.ItemIsEditable`)

**Использует:**
- `PyQt5.QtWidgets.QTableWidgetItem` для создания элементов таблицы
- `PyQt5.QtCore.Qt` для настроек выравнивания и флагов

##### `show_info(self)`
**Описание:**  
Отображает информационное окно через [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) с предупреждением об ошибках входа.

**Параметры окна:**
- Заголовок: "Внимание!"
- Текст: "При попытке загрузки данных\nпроизошла ошибка входа в аккаунт"
- Звуковое уведомление: "notification.mp3"

#### Особенности реализации

1. **Работа с таблицей:**
   - Автоматическая нумерация строк
   - Разрешение редактирования только колонки с решением
   - Единообразное оформление всех ячеек

2. **Интеграция:**
   - Использует [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для показа уведомления
   - Наследует UI-класс `DialogErrorAddAccountsUi`

3. **Безопасность:**
   - Проверка существования пути к Qt plugins перед установкой
   - Обработка ошибок импорта PyQt5

4. **UI/UX:**
   - Четкое структурирование информации
   - Звуковое уведомление о проблеме
   - Простое закрытие окна через кнопку

### Пример использования
```python
# Создание и отображение окна с аккаунтами с ошибками
error_accounts = [
    [12345, "user1", "2FA enabled", "Disable 2FA or add new tdata"],
    [67890, "user2", "Flood wait", "Wait before retrying"]
]
dialog = DialogErrorOpenAccounts(error_accounts)
dialog.exec_()  # Показ модального окна
```

### Связи с другими модулями
- Наследует UI-класс из [`DialogErrorAddAccountsUi`]()
- Использует [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для показа уведомления
- Интегрирован с процессом добавления аккаунтов через [`add_accounts.py`](#добавление-новых-аккаунтов-add_accountspy)

## Ошибка открытия аккаунта при добавлении нового аккаунта (error_open_accounts.py)

### Общее описание
Модуль `error_open_accounts.py` реализует диалоговое окно для отображения информации об аккаунтах, при открытии которых произошли ошибки во время процесса добавления новых аккаунтов в программу. Основные функции:

- Отображение списка аккаунтов с ошибками в табличном виде
- Показ детальной информации о каждой ошибке (тип ошибки и рекомендуемое решение)
- Интеграция с системой уведомлений через [`DialogInfo`](#диалоговое-окно-с-информацией-infopy)

**Ключевые особенности:**
- Центрирование содержимого всех ячеек таблицы
- Возможность редактирования только поля с решением проблемы
- Автоматическое определение пути к Qt plugins для корректной работы PyQt5
- Проигрывание звукового уведомления при показе информации об ошибке

### Класс `DialogErrorOpenAccounts(DialogErrorAddAccountsUi)`

#### Конструктор
```python
def __init__(self, accounts: list)
```

**Параметры:**
- `accounts` (list) - список аккаунтов с ошибками, где каждый аккаунт представлен вложенным списком формата:  
  `[id_tg: int, user_name: str, error: str, solution: str]`  
  Пример:
  ```python
  [
      [432432, 'user1', 'Двухфакторная аутентификация', 'Добавить новую tdata'],
      [872432, 'user2', 'Неизвестная ошибка', 'Проверить аккаунт']
  ]
  ```

**Инициализирует:**
- Список аккаунтов (`self.accounts = accounts`)
- Настройку пути к Qt plugins через:
  ```python
  qt_plugins_path = str(Path(PyQt5.__file__).parent / "Qt5" / "plugins")
  os.environ["QT_QPA_PLATFORM_PLUGIN_PATH"] = qt_plugins_path
  ```
- Подключение обработчика события для кнопки закрытия окна
- Вызов методов:
  - `show_accounts()` - заполнение таблицы данными
  - `show_info()` - показ информационного сообщения

#### Методы

##### `show_accounts(self)`
**Описание:**  
Заполняет таблицу `tableWidget_account` данными об аккаунтах с ошибками.

**Логика работы:**
1. Очищает таблицу (`setRowCount(0)`)
2. Для каждого аккаунта в `self.accounts`:
   - Добавляет новую строку (`insertRow()`)
   - Создает элементы таблицы (`QTableWidgetItem`) для:
     - Порядкового номера (столбец 0)
     - Telegram ID (столбец 1)
     - Юзернейма (столбец 2)
     - Описания ошибки (столбец 3)
     - Решения проблемы (столбец 4)
3. Настраивает элементы:
   - Центрирование текста (`Qt.AlignCenter`)
   - Запрет редактирования для всех столбцов, кроме "Решение"
   - Размер шрифта (9 пунктов)

**Особенности:**
- Последний столбец ("Решение") остается редактируемым
- Все данные преобразуются в строки (`str()`) перед отображением

##### `show_info(self)`
**Описание:**  
Отображает информационное окно [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) с сообщением об ошибке.

**Параметры окна:**
- Заголовок: "Внимание!"
- Текст: "При попытке загрузки данных\nпроизошла ошибка входа в аккаунт"
- Звуковое уведомление: "notification.mp3"

**Использует:**
- [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для показа сообщения
- Файл звукового уведомления из `/resources/sounds/`

#### Сигналы
- `pushButton_close.clicked` - закрытие окна при нажатии кнопки

### Особенности реализации

1. **Работа с таблицей:**
   - Автоматическое определение количества строк
   - Центрирование содержимого всех ячеек
   - Избирательное разрешение редактирования (только столбец с решением)

2. **Интеграция:**
   - Использует [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для показа сообщений
   - Наследует UI-класс `DialogErrorAddAccountsUi`

3. **Безопасность:**
   - Проверка существования Qt plugins path перед установкой
   - Преобразование всех данных в строки перед отображением

4. **UI/UX:**
   - Четкое структурирование информации
   - Звуковое уведомление о проблеме
   - Единообразное оформление таблицы

### Пример использования
```python
# Подготовка данных
problem_accounts = [
    [123456, 'test_user', 'Ошибка входа', 'Проверить tdata'],
    [789012, 'another_user', 'Бан', 'Разблокировать аккаунт']
]

# Создание и отображение окна
dialog = DialogErrorOpenAccounts(problem_accounts)
dialog.exec_()  # Показ модального окна
```

### Связи с другими модулями
- Наследует UI-класс из [`DialogErrorAddAccountsUi`]()
- Использует [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для показа сообщений
- Интегрирован с процессом добавления аккаунтов через [`add_accounts.py`](#добавление-новых-аккаунтов-add_accountspy)


## Информация о добавлении аккаунтов (info_add_accounts.py)

### Класс DialogInfoAddAccounts(self):
**Описание** 
Это окно записывает данные в [БД](#таблица-autofill_settings) для настройки автозаполнения аккаунтов при их добавлении<br>
В правой верхней части есть знак вопроса при нажатии на которого будет высвечено диалоговое окно
[Информация о выборе папке для добавления аккаунтов](#информация-о-выборе-папке-для-добавления-аккаунтов-info_add_folder_accountspy). Оно указывает на папку которую необходимо указать <br>

**Cобытия** <br>
При клике на кнопку pushButton_info_folder вызывается метод self.open_info_folder() который открывает 
[Информация о выборе папке для добавления аккаунтов](#информация-о-выборе-папке-для-добавления-аккаунтов-info_add_folder_accountspy)<br>
При клике на кнопку pushButton_choose вызывается метод self.open_folder_dialog() <br>
При клике на кнопку checkBox_use_autofill вызывается метод self.change_checkbox_use_autofill() <br>
при клике на любой checkBox который обрабатывается он попадёт в метод которой предназначен только для этой строки с checkBox.
все checkBox сперва станут неактивными, а после выбранный checkBox станет активным.

### **Методы:** <br>
### def change_checkbox_...(self, checkbox_target: QCheckBox, last_checked: bool):
Вместо `...` может быть "avatar", "name", "surname" (логика везде одинаковая, отличается только check box для изменения)<br>
Принимает: <br>
`checkbox_target: QCheckBox` нажатый check box <br>
`last_checked: bool` какое состояние у нажатого check box (активный или неактивный) <br>
Ничего не возвращает <br>
в соответствии какой check box был нажат будет сделана вся строка у этих check box неактивной, а у выбранного check box
будет установлен состояние в соответствии с переданным last_checked <br>

### def change_checkbox_use_autofill(self):
Ничего не принимает и ничего не возвращает <br>
Возникает при изменении check box автозаполнения. Если он активный,
то окно расширится и будут отображаться настройки для автозаполнения аккаунт, иначе будет обратное действие

### def open_folder_dialog(self):
Открывает проводник в котором необходимо выбрать папку для добавления аккаунта<br>
Если она выбрана проверяем необходимость выполнять автозаполнение.
Если автозаполнению необходимо, то считываем данные с check box, и в соответствии сс ними заполняем БД,
иначе обнуляем эти данные. После возвращаем путь к выбранной папки `str` и закрываем данное окно.

## Информация о выборе папке для добавления аккаунтов (info_add_folder_accounts.py)
### Класс InfoAddFolder(self):
Просто отображает изображение где указанно какую папку необходимо выбрать для добавления аккаунта: <br>
<img alt="info_add_accounts.png" src="resources/icon/info_add_accounts.png"/>

Такая структура выбрана для облегчения процесса добавления новых аккаунтов, потому что когда покупается аккаунт,
данные о нём (tdata) хранятся в архиве.


## Полная информация о выбранном аккаунте (more_info_account.py

### Класс DialogMoreInfoAccount(id: int, account_type: str):

**Конструктор:**
```
def __init__(self, id: int, account_type: str):
```
- `id` (int): ID папки аккаунта в системе
- `account_type` (str): Тип аккаунта ('active', 'archive', 'main', 'temporary_ban', 'login_error')

**Инициализирует:**
- Сохранение оригинального socket (для восстановления после использования прокси)
- Корневая директория проекта (`self.root_project_dir = '..'`)
- Обработчики событий для кнопок закрытия и сохранения

### **Методы:**

#### `async save_data()`:
**Описание:**  
Асинхронно сохраняет измененные данные аккаунта (имя, фамилию, юзернейм, био, заметки) через Telegram API. Для аккаунтов с ошибкой входа (`login_error`) сохраняет только заметки.

**Логика работы:**
1. Для `login_error`:
   - Сохраняет только заметки в БД
   - Выводит уведомление об успехе
2. Для других типов:
   - Проверяет прокси (если включено в настройках)
   - Подключается к аккаунту через `TDesktop` и `Telethon`
   - Обновляет данные через API:
     - Имя (`UpdateProfileRequest`)
     - Фамилия (`UpdateProfileRequest`)
     - Юзернейм (`UpdateUsernameRequest`)
     - Био (`UpdateProfileRequest`)
   - Фиксирует изменения в БД
   - Обрабатывает ошибки (включая занятый юзернейм `UsernameOccupiedError`)

**Возвращает:**  
Нет, но показывает диалог с результатом операции.

#### `comparison_with_DB(id_tg: int, user_name: str, name: str, phone: str)`:
**Описание:**  
Сравнивает текущие данные аккаунта с данными в БД и обновляет их при расхождениях.

**Параметры:**
- `id_tg` (int): Telegram ID
- `user_name` (str): Юзернейм
- `name` (str): Имя
- `phone` (str): Номер телефона

**Возвращает:**  
Нет, но обновляет БД при необходимости.

#### `show_error_proxy(ip: str, port: str, login: str, password: str)`:
**Описание:**  
Показывает окно ошибки прокси (`DialogErrorProxy`) и перезагружает данные аккаунта.

**Параметры:**  
Данные прокси для отображения в диалоге.

#### `show_from_db()`:
**Описание:**  
Отображает информацию для аккаунтов с ошибкой входа (`login_error`), где данные берутся только из БД (без подключения к Telegram).

**Особенности:**
- Скрывает поля для редактирования фамилии и био
- Показывает информацию об ошибке и её решении
- Форматирует время с момента добавления аккаунта (например, "114 дней")

#### `async show_info_account()`:
**Описание:**  
Основной метод для отображения данных аккаунта. Подключается к аккаунту через Telegram API или использует данные из БД для `login_error`.

**Логика работы:**
1. Для `login_error`: вызывает `show_from_db()`
2. Для других типов:
   - Проверяет и настраивает прокси
   - Получает данные через `TDesktop` и `Telethon`:
     - Основная информация (`get_me()`)
     - Полный профиль (`GetFullUserRequest`)
   - Определяет страну по номеру телефона (`get_country_flag`)
   - Рассчитывает время с момента добавления аккаунта
   - Обновляет интерфейс:
     - ID, юзернейм, имя, фамилия
     - Флаг страны
     - Номер телефона
     - Био
     - Статус аккаунта (активный/архив и т.д.)
     - Заметки

**Обработка ошибок:**  
При ошибке входа перемещает аккаунт в соответствующую папку через [`error_handler`](#обработчик-ошибок-error_handlerpy) и показывает описание проблемы.

### **Особенности реализации:**
1. **Интеграция с прокси:**  
   - Автоматическое восстановление оригинального socket после операций
   - Проверка работоспособности прокси через [`check_proxy`](#проверка-прокси-check_proxypy)

2. **Локализация времени:**  
   - Преобразует даты из БД в формат "дни назад" с правильным склонением (1 день, 2 дня, 5 дней)

3. **Геолокация:**  
   - Использует модуль [`flag.py`](#получение-geo-по-номеру-flagpy) для определения страны по номеру телефона
   - Отображает соответствующий флаг (или `default_flag.png` если неизвестен)

4**Визуальные элементы:**  
   - Динамическая подстройка ширины полей под текст
   - Разные макеты для [`error_handler`](#обработчик-ошибок-error_handlerpy) и других типов аккаунтов

### **Пример использования:**
```
# Создание и отображение окна
dialog = DialogMoreInfoAccount(5, 'active')  # ID=5, активный аккаунт
asyncio.run(dialog.show_info_account())      # Загрузка данных
dialog.exec_()                               # Показ модального окна
```

## Получение geo по номеру (flag.py)

Содержит функцию для определения страны по номеру телефона и список допустимых кодов стран.

### **Константа:**
`COUNTRY_CODES` - Список всех поддерживаемых двухбуквенных кодов стран (ISO 3166-1 alpha-2) в нижнем регистре.

### **Функция:**
#### `get_country_flag(phone_number: str) -> str`:
**Описание:**  
Определяет страну номера телефона и возвращает её код для отображения соответствующего флага.

**Параметры:**
- `phone_number` (str): Номер телефона в международном формате (с `+` или без)

**Возвращает:**
- `str`: Код страны в нижнем регистре (например, `'ru'`) или `'default_flag'`, если:
  - Не удалось распознать номер
  - Код страны не найден в `COUNTRY_CODES`

**Особенности:**
- Автоматически добавляет `+` если отсутствует
- Использует библиотеку [`phonenumbers`](https://github.com/daviddrysdale/python-phonenumbers)
- Обрабатывает ошибки парсинга номера

**Используется в:**  
[`DialogMoreInfoAccount`](#полная-информация-о-выбранном-аккаунте-more_info_accountpy) для отображения флага страны аккаунта.



## Раздел конвертирование сессии (convert.py)
## Главный раздел (convert.py)

### Общее описание
Модуль `convert.py` предоставляет функционал для конвертации между форматами хранения данных Telegram-аккаунтов:
- Конвертация из папки `tdata` в файл `.session` (Telethon)
- Конвертация из файла `.session` в папку `tdata` (TDesktop)

**Ключевые особенности:**
- Поддержка работы через прокси (SOCKS5)
- Валидация входных данных
- Автоматическая очистка временных файлов
- Интеграция с основной БД проекта

### Класс `WindowConvert(WindowConvertUi)`
Наследуется от сгенерированного UI-класса `WindowConvertUi`. Управляет интерфейсом конвертации и обработкой событий.

**Конструктор:**
```python
def __init__(self, switch_window):
```
- `switch_window` - функция для переключения между окнами приложения

**Инициализирует:**
- Очистку временных файлов предыдущих сессий
- Подключение обработчиков событий кнопок
- Настройку пути к Qt plugins (необходимо для корректной работы PyQt5)

### **Методы:**

#### `_info_convert_in_session()`
**Описание:**  
Отображает информационное окно ([`DialogInfo`](#диалоговое-окно-с-информацией-infopy)) с инструкцией по конвертации `tdata` в `.session`.

**Логика работы:**
1. Создает экземпляр `DialogInfo` с текстом:
   ``` 
   "Укажите путь к папке Tdata\n\nВ ней хранятся данные для входа в аккаунт и настройки аккаунта\n
   Будет произведена попытка входа и в случае успеха сформируется файл .session"
   ```
2. Проигрывает звуковое уведомление `notification.mp3`

#### `_info_convert_in_tdata()`
**Описание:**  
Отображает информационное окно ([`DialogInfo`](#диалоговое-окно-с-информацией-infopy)) с инструкцией по конвертации `.session` в `tdata`.

**Логика работы:**
1. Создает экземпляр `DialogInfo` с текстом:
   ```
   "Укажите путь к файлу с расширением .session\n\nЭто файл с данными для входа в аккаунт\n
   Будет произведена попытка входа и в случае успеха сформируется папка Tdata"
   ```
2. Проигрывает звуковое уведомление `notification.mp3`

#### `_check_proxy()`
**Описание:**  
Проверяет работоспособность прокси из БД через [`check_proxy`](#проверка-прокси-check_proxypy).

**Возвращает:**
- `list` - Данные прокси `[ip, port, login, password]` если проверка успешна
- `None` - Если прокси нерабочий (при этом показывает [`DialogErrorProxyForWork`](#диалоговое-окно-при-ошибке-прокси-для-работы-с-другими-разделами-error_proxy_for_workpy))

**Логика работы:**
1. Получает данные прокси из БД (`proxy` таблица)
2. Проверяет через `check_proxy()`
3. При ошибке показывает диалог с возможностью:
   - Повторить проверку
   - Продолжить без прокси

#### `async _convert_in_session()`
**Описание:**  
Конвертирует папку `tdata` в файл `.session` через `TDesktop` и `Telethon`.

**Логика работы:**
1. Проверяет прокси (если включено в настройках)
2. Открывает диалог выбора папки (`QFileDialog.getExistingDirectory`)
3. Очищает временные файлы предыдущих сессий
4. Пытается создать сессию:
   ```python
   tdesk = TDesktop(tdata_path)
   client = await tdesk.ToTelethon(
       session=f"{self.root_project_dir}/working_files/convert_file/account.session",
       flag=UseCurrentSession
   )
   await client.connect()
   ```
5. При успехе:
   - Предлагает выбрать папку для сохранения
   - Копирует файл с уникальным именем (добавляет `(N)` при конфликтах)
6. При ошибке:
   - Показывает [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) с описанием проблемы
   - Гарантирует отключение клиента

**Обрабатывает исключения:**
- `TFileNotFound` - Некорректный путь к `tdata`
- Общие ошибки подключения

#### `async _convert_in_tdata()`
**Описание:**  
Конвертирует файл `.session` в папку `tdata` через `Telethon` и `TDesktop`.

**Логика работы:**
1. Проверяет прокси (если включено в настройках)
2. Открывает диалог выбора файла (`QFileDialog.getOpenFileName`)
3. Очищает временные папки предыдущих сессий
4. Пытается создать `tdata`:
   ```python
   client = TelegramClient(session_path)
   tdesk = await client.ToTDesktop(flag=UseCurrentSession)
   await client.connect()
   tdesk.SaveTData(f'{self.root_project_dir}/working_files/convert_file/tdata')
   ```
5. При успехе:
   - Предлагает выбрать папку для сохранения
   - Копирует папку с уникальным именем
6. При ошибке:
   - Показывает [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) с описанием проблемы

### Особенности реализации
1. **Работа с файлами:**
   - Автоматическая очистка временных файлов перед конвертацией
   - Обработка конфликтов имен через добавление суффиксов `(1)`, `(2)` и т.д.
   - Сохранение результатов в `working_files/convert_file/`

2. **Безопасность:**
   - Восстановление оригинального socket после операций с прокси
   - Гарантированное освобождение ресурсов (даже при ошибках)

3. **Интеграция:**
   - Использует общие механизмы работы с прокси из БД
   - Следует стилю обработки ошибок проекта

4. **Производительность:**
   - Асинхронные операции для избежания блокировки UI
   - Таймауты подключения (7-10 секунд)

### Примеры использования
```python
# Конвертация tdata -> session
asyncio.run(self._convert_in_session())

# Конвертация session -> tdata 
asyncio.run(self._convert_in_tdata())
```

### Связи с другими модулями
- Использует [`check_proxy`](#проверка-прокси-check_proxypy) для проверки прокси
- Показывает ошибки через [`DialogErrorProxyForWork`](#диалоговое-окно-при-ошибке-прокси-для-работы-с-другими-разделами-error_proxy_for_workpy)
- Взаимодействует с БД через `sqlite3` (таблица `proxy`)



## Раздел создание каналов (create_channel.py)
## Главный раздел (create_channel.py)

### Общее описание
Модуль `create_channel.py` реализует функционал массового создания Telegram-каналов через аккаунты программы. Поддерживает:
- Создание каналов с настраиваемыми параметрами (имя, описание, юзернейм)
- Установку аватара канала
- Отправку первого сообщения в канал (текст/файл/пересылка)
- Настройку задержки между созданиями
- Ограничение количества каналов с одного аккаунта
- Многопоточное создание
- Обработку ошибок и ведение статистики

**Ключевые особенности:**
- Гибкая система генерации уникальных юзернеймов
- Поддержка случайного выбора аватаров из папки
- Интеграция с прокси (SOCKS5)
- Сохранение настроек между сеансами в БД

### Классы

#### `CreatingChannelWithStreams(QThread)`
Поток для многопоточного создания каналов. Каждый экземпляр работает с одним аккаунтом.

**Конструктор:**
```python
def __init__(self, id_account: int, channel_name: list, delay: int, 
             max_channel_from_one_account: int, avatar_path: list,
             send_first_message: dict, user_name: list, 
             set_numbers_end_user_name: bool, description: list,
             use_proxy: bool, ip: str, port: int, login: str, password: str)
```

**Параметры:**
- `id_account` - ID папки аккаунта в директории `active_accounts`
- `channel_name` - Список имен для создаваемых каналов
- `delay` - Задержка между созданиями в секундах
- `max_channel_from_one_account` - Максимум каналов с одного аккаунта
- `avatar_path` - Список путей к файлам аватаров (пустой, если не используется)
- `send_first_message` - Словарь с параметрами первого сообщения:
  - `use_new_message` - Флаг отправки нового сообщения
  - `use_file_for_message` - Флаг отправки файла
  - `file_path` - Путь к файлу
  - `message` - Текст сообщения
  - `use_the_forwarded_message` - Флаг пересылки сообщения
  - `user_name_channel` - Юзернейм канала-источника
  - `message_ID` - ID сообщения для пересылки
- `user_name` - Список юзернеймов для каналов
- `set_numbers_end_user_name` - Флаг добавления цифр если юзернейм занят
- `description` - Список описаний каналов
- `use_proxy` - Флаг использования прокси
- `ip`, `port`, `login`, `password` - Данные прокси

**Методы:**
- `run()` - Точка входа потока
- `run_2()` - Основная асинхронная логика создания каналов
- `quit_async()` - Асинхронное завершение потока

**Сигналы:**
```python
task_done = pyqtSignal(str, list, bool, list, list, str, list, bool)
```
Возвращает:
1. Текст для лога
2. Статистику [успешные, неудачные]
3. Флаг бана аккаунта
4. Данные аккаунта [TG ID, время использования]
5. Список созданных юзернеймов
6. Текст ошибки
7. Данные об ошибке [тип, ID аккаунта]
8. Флаг завершения работы

#### `WindowCreateChannel(WindowCreateChannelUi)`
Главное окно управления созданием каналов. Наследуется от сгенерированного UI.

**Атрибуты:**
- `launched_create` - Флаг активности процесса создания
- `active_threads` - Список активных потоков
- `original_socket` - Оригинальный socket до изменения прокси
- `id_and_last_use` - Данные об использованных аккаунтах
- `user_names_created_channel` - Список созданных юзернеймов
- Статистические переменные (`count_attempts`, `quantity_accounts_for_create_channel` и др.)
- Данные из БД:
  - `data_first_message` - Параметры первого сообщения
  - `data_for_user_name_channel` - Настройки генерации юзернеймов

**Методы:**

##### Основные
- `_start()` - Запуск/остановка создания каналов
- `_clear_conclusion()` - Очистка лога и статистики
- `_transition()` - Переключение между окнами программы

##### Обработчики
- `_handler_signal_with_streams()` - Обработчик сигналов потоков создания

##### Вспомогательные
- `_generate_unique_user_name()` - Генерация уникальных юзернеймов
- `_choose_file_for_mailing()` - Выбор файла для первого сообщения
- `_choose_user_name()` - Настройка генерации юзернеймов
- `_choice_photo()` - Открытие папки с аватарами
- `_update_data_in_db()` - Сохранение настроек в БД
- `_set_enabled_for_elements()` - Блокировка/разблокировка UI

### Логика работы

1. **Подготовка:**
   - Проверка заполненности обязательных полей
   - Загрузка сохраненных настроек из БД (`saved_data_creating_channels`)
   - Генерация списка юзернеймов через `_generate_unique_user_name()`
   - Проверка прокси через [`check_proxy`](#проверка-прокси-check_proxypy)

2. **Запуск:**
   - Распределение параметров (имен, описаний, аватаров) между потоками
   - Создание потоков `CreatingChannelWithStreams` для каждого аккаунта
   - Подключение обработчиков сигналов

3. **Создание канала:**
   - Создание через `CreateChannelRequest`
   - Установка юзернейма (`UpdateUsernameRequest`) с обработкой ошибок:
     - `UsernameOccupiedError` - добавление цифр если `set_numbers_end_user_name`
     - `ChannelsAdminPublicTooMuchError` - превышение лимита публичных каналов
   - Установка аватара (`EditPhotoRequest`)
   - Отправка первого сообщения:
     - Текст/файл через `send_message`/`send_file`
     - Пересылка через `forward_messages`

4. **Обработка ошибок:**
   - Ошибки аккаунтов обрабатываются через [`error_handler`](#обработчик-ошибок-error_handlerpy)
   - Ошибки каналов (некорректные имена, аватары и др.) логируются

5. **Завершение:**
   - Обновление времени последнего использования аккаунтов
   - Показ списка созданных юзернеймов через [`DialogListCreateChannel`](#класс-dialoglistcreatechanneldialoglistcreatechannelui)
   - Восстановление оригинального socket

### Примеры использования

**Запуск создания каналов:**
```python
# Подготовка данных
channel_names = ["Channel 1", "Channel 2"]
descriptions = ["Desc 1", "Desc 2"]
user_names = ["channel1", "channel2"]

# Создание потока
creator = CreatingChannelWithStreams(
    id_account=0,
    channel_name=channel_names,
    delay=10,
    max_channel_from_one_account=2,
    avatar_path=["avatar1.jpg", "avatar2.jpg"],
    send_first_message={
        'use_new_message': True,
        'message': 'Hello!',
        'use_file_for_message': False,
        'file_path': '',
        'use_the_forwarded_message': False,
        'user_name_channel': '',
        'message_ID': ''
    },
    user_name=user_names,
    set_numbers_end_user_name=True,
    description=descriptions,
    use_proxy=True,
    ip="proxy_ip",
    port=1080,
    login="user",
    password="pass"
)

# Подключение обработчика и запуск
creator.task_done.connect(handler)
creator.start()
```

### Особенности реализации

1. **Генерация юзернеймов:**
   - Поддержка комбинирования из нескольких списков
   - Автоматическая проверка на валидность (5-32 символа, нельзя начинать с цифры и др.)
   - Добавление случайных цифр при занятости юзернейма

2. **Работа с файлами:**
   - Поддержка изображений (JPG, PNG, GIF) для аватаров
   - Проверка существования файлов перед отправкой

3. **Безопасность:**
   - Восстановление оригинального socket после завершения
   - Гарантированное отключение клиента Telethon

4. **Производительность:**
   - Равномерное распределение нагрузки между потоками
   - Минимизация блокировок UI

5. **Сохранение данных:**
   - Автоматическое сохранение настроек в БД при изменении
   - Восстановление параметров при запуске

Модуль интегрирован с основной БД программы (`data_base.sqlite3`) и использует общие механизмы работы с прокси и обработки ошибок.


## Диалоговое окно с первым сообщением в канал (first_message_for_group.py)

### Общее описание
Модуль `first_message_for_group.py` реализует функционал настройки первого сообщения для создаваемых Telegram-каналов. Позволяет выбрать один из трёх вариантов:
1. **Новое сообщение** - с возможностью добавления текста (с HTML-разметкой) и файла
2. **Пересылка сообщения** - из существующего канала/чата
3. **Без сообщения** - канал создаётся пустым

**Ключевые особенности:**
- Валидация HTML-разметки через [`check_html_parse`](#проверка-html-разметки-check_html_parsepy)
- Ограничение длины сообщения (4024 символа без файла, 1024 с файлом)
- Проверка доступности файлов (максимум 2GB)
- Интеграция с основной БД проекта (`saved_data_creating_channels`)
- Поддержка drag-and-drop для перемещения окна

### Классы

#### `DraggableLabel(QLabel)`
Кастомный QLabel с возможностью перемещения окна при drag-and-drop.

**Методы:**
- `mousePressEvent()` - Запоминает позицию мыши при нажатии
- `mouseMoveEvent()` - Перемещает окно при движении мыши с зажатой кнопкой
- `mouseReleaseEvent()` - Сбрасывает позицию при отпускании кнопки

#### `DialogFirstMessage(DialogFirstMessageUi)`
Главное диалоговое окно настроек первого сообщения. Наследуется от сгенерированного UI.

**Конструктор:**
```python
def __init__(self, data: dict)
```
Принимает словарь с начальными данными:
```python
{
    'message': str,               # Текст сообщения
    'user_name_channel': str,     # Юзернейм канала для пересылки
    'message_ID': str,            # ID сообщения для пересылки
    'file_path': str,             # Путь к файлу
    'use_file_for_message': bool, # Флаг использования файла
    'use_new_message': bool,      # Флаг нового сообщения
    'use_the_forwarded_message': bool # Флаг пересылки
}
```

**Сигналы:**
```python
data_returned = pyqtSignal(dict)  # Возвращает обновлённые данные
```

### Методы

#### `_info_forwarded_message()`
Отображает инструкцию по получению ID сообщения через [`DialogInfo`](#диалоговое-окно-с-информацией-infopy):
- Как скопировать ссылку на сообщение
- Формат ссылки (`t.me/username/123`)
- Требование публичности канала

#### `_choose_file_for_message()`
Открывает диалог выбора файла (`QFileDialog`) с проверками:
1. **Размер файла** - не более 2GB
2. **Доступность** - проверка занятости файла другим процессом
3. **Копирование** - сохранение в `/working_files/file_from_user/`

При ошибках показывает соответствующие уведомления через [`DialogInfo`](#диалоговое-окно-с-информацией-infopy).

#### `_change_checkbox_message(checkbox_target: QCheckBox, last_checked: bool)`
Обрабатывает переключение между типами сообщений:
- Деактивирует все чекбоксы
- Активирует только выбранный
- Гарантирует выбор только одного варианта

#### `_save()`
Основной метод сохранения данных с валидацией:

1. **Для нового сообщения**:
   - Проверка заполненности текста
   - Валидация HTML через [`check_html_parse`](#проверка-html-разметки-check_html_parsepy)
   - Проверка длины (4024/1024 символов)
   - Проверка наличия файла (если выбран)

2. **Для пересылки**:
   - Проверка юзернейма канала
   - Проверка ID сообщения

3. **Общее**:
   - Сохранение в БД (`saved_data_creating_channels`)
   - Отправка сигнала `data_returned` с обновлёнными данными

### Логика работы

1. **Инициализация**:
   - Установка Qt plugins path (необходимо для корректной работы PyQt5)
   - Загрузка переданных данных в UI-элементы
   - Подключение обработчиков событий

2. **Работа с файлами**:
   - Копирование выбранного файла в рабочую директорию
   - Обработка ошибок доступа (`PermissionError`)

3. **Валидация**:
   - Проверка HTML-тегов через `check_html_parse`
   - Контроль длины сообщения
   - Проверка обязательных полей

4. **Сохранение**:
   - Обновление данных в БД
   - Формирование возвращаемого словаря

### Пример использования
```python
# Инициализация с тестовыми данными
data = {
    'message': 'Тестовое сообщение',
    'user_name_channel': '@channel',
    'message_ID': '123',
    'file_path': '',
    'use_file_for_message': False,
    'use_new_message': True,
    'use_the_forwarded_message': False
}

dialog = DialogFirstMessage(data)
dialog.data_returned.connect(handler)  # Подключение обработчика
dialog.exec_()  # Показ модального окна
```

### Особенности реализации

1. **Безопасность**:
   - Проверка файлов перед копированием
   - Обработка исключений при работе с БД

2. **Интеграция**:
   - Использует [`check_html_parse`](#проверка-html-разметки-check_html_parsepy) для валидации
   - Сохраняет данные в таблицу `saved_data_creating_channels`

3. **UI/UX**:
   - Поддержка drag-and-drop через `DraggableLabel`
   - Информативные уведомления об ошибках
   - Чёткое разделение вариантов сообщений

4. **Ограничения**:
   - Максимальный размер файла - 2GB
   - Максимальная длина текста - 4024 символа
   - Только один активный вариант сообщения

Модуль тесно интегрирован с [`create_channel.py`](#главный-раздел-create_channelpy) и используется при настройке процесса создания каналов.


## Диалоговое окно с созданными каналами (list_created_channel.py)

### Общее описание
Модуль `list_created_channel.py` реализует диалоговое окно для отображения списка созданных каналов и их юзернеймов. Основные функции:
- Показывает список юзернеймов созданных каналов
- Предоставляет возможность сохранения списка в текстовый файл
- Поддерживает уникальные имена файлов при сохранении

**Ключевые особенности:**
- Автоматическое определение пути к Qt plugins
- Обработка конфликтов имен файлов при сохранении
- Простое текстовое представление данных
- Интеграция с системой уведомлений через [`DialogInfo`](#диалоговое-окно-с-информацией-infopy)

### Класс `DialogListCreateChannel(DialogListCreateChannelUi)`
Наследуется от сгенерированного UI-класса `DialogListCreateChannelUi`. Отображает список юзернеймов и предоставляет функционал для их сохранения.

**Конструктор:**
```python
def __init__(self, user_name_create_channel: list):
```
- `user_name_create_channel` - Список юзернеймов созданных каналов

**Инициализирует:**
- Корневую директорию проекта (`self.root_project_dir = '..'`)
- Заполнение текстового поля `textEdit_user_name_list` переданными юзернеймами
- Подключение обработчиков событий для кнопок:
  - `pushButton_close` и `pushButton_close_2` - закрытие окна
  - `pushButton_upload` - сохранение списка юзернеймов

### **Методы:**

#### `_upload_user_name()`
**Описание:**  
Открывает диалог выбора папки и сохраняет список юзернеймов в текстовый файл. Обрабатывает конфликты имен через добавление суффиксов `(1)`, `(2)` и т.д.

**Логика работы:**
1. Получает путь к рабочему столу пользователя
2. Открывает диалог выбора папки через `QFileDialog`
3. При успешном выборе:
   - Пытается создать файл с базовым именем `User_name созданных каналов.txt`
   - При конфликте имен добавляет суффикс `(N)`
   - Сохраняет содержимое `textEdit_user_name_list` в файл
   - Показывает уведомление об успехе через [`DialogInfo`](#диалоговое-окно-с-информацией-infopy)
4. При ошибке показывает соответствующее уведомление

**Использует:**
- [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для отображения результатов операции
- Стандартный механизм Qt для работы с файлами

### Особенности реализации

1. **Работа с путями:**
   - Автоматическое определение пути к Qt plugins (необходимо для корректной работы `QFileDialog`)
   - Обработка домашней директории пользователя через `os.path.expanduser`

2. **Безопасность:**
   - Явное указание кодировки UTF-8 при работе с файлами
   - Обработка исключений `FileExistsError` и `FileNotFoundError`

3. **Интеграция:**
   - Используется в [`create_channel.py`](#раздел-создание-каналов-create_channelpy) для отображения результатов создания каналов
   - Следует общему стилю обработки ошибок проекта

### Пример использования

```python
# Создание и отображение окна
dialog = DialogListCreateChannel(['channel1', 'channel2', 'channel3'])
dialog.exec_()  # Показ модального окна
```

### Связи с другими модулями
- Получает данные из [`create_channel.py`](#раздел-создание-каналов-create_channelpy)
- Использует [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для уведомлений




## Диалоговое окно с формированием user_name для канала (user_name_for_channel.py)

### Общее описание
Модуль `user_name_for_channel.py` реализует функционал генерации и валидации user_name для Telegram-каналов. Основные возможности:
- Генерация уникальных user_name путем комбинации слов из нескольких списков
- Проверка на соответствие требованиям Telegram
- Сохранение настроек генерации в БД
- Визуализация процесса через диалоговое окно PyQt5

**Ключевые особенности:**
- Поддержка 3 независимых списков слов для генерации
- Гибкая система включения/исключения списков из генерации
- Валидация по длине, допустимым символам и запрещенным именам
- Сохранение истории введенных списков слов

### Класс `DialogUserNameForChannel(DialogUserNameForChannelUi)`
Наследуется от сгенерированного UI-класса `DialogUserNameForChannelUi`. Управляет интерфейсом генерации user_name и обработкой событий.

**Конструктор:**
```python
def __init__(self, data: dict)
```
Принимает словарь с начальными данными:
```python
{
    'first_list': str,       # Содержимое первого списка слов
    'second_list': str,      # Содержимое второго списка слов  
    'third_list': str,       # Содержимое третьего списка слов
    'use_first_list': bool,  # Флаг использования первого списка
    'use_second_list': bool, # Флаг использования второго списка
    'use_third_list': bool,  # Флаг использования третьего списка
    'set_numbers_end_user_name': bool # Флаг добавления цифр в конец
}
```

**Инициализирует:**
- Заполнение полей ввода переданными данными
- Подключение обработчиков событий кнопок
- Настройку автоматического удаления пробелов в полях ввода

### **Методы:**

#### `_generate_unique_user_name(data: list[str]) -> dict`
**Описание:**  
Генерирует уникальные user_name из входных данных, проверяет их на соответствие требованиям Telegram.

**Логика работы:**
1. Разделяет строки по переводам строки и приводит к нижнему регистру
2. Генерирует все возможные комбинации из выбранных списков через `itertools.product`
3. Проверяет каждую комбинацию на:
   - Длину (5-32 символа)
   - Запрещенные символы (только a-z, 0-9, _)
   - Запрещенные имена (admin, telegram, support)
   - Нельзя начинать/заканчивать на `_`
   - Нельзя начинать с цифры
4. Удаляет дубликаты через `set()`
5. Перемешивает результат через `random.shuffle()`

**Параметры:**
- `data` (list[str]): Список строк, каждая может содержать несколько слов, разделенных `\n`

**Возвращает:**
```python
{
    "user_names": list,                   # Валидные user_name
    "there_are_inappropriate_values": bool # Флаг наличия невалидных значений
}
```

#### `_info()`
**Описание:**  
Отображает информационное окно ([`DialogInfo`](#диалоговое-окно-с-информацией-infopy)) с правилами формирования user_name.

**Отображаемая информация:**
- Ограничения длины (5-32 символа)
- Допустимые символы (a-z, 0-9, _)
- Запрещенные имена (admin, telegram, support)
- Правила генерации из нескольких списков
- Примеры формирования

#### `_save()`
**Описание:**  
Основной метод сохранения результатов. Выполняет:
1. Проверку выбора хотя бы одного списка
2. Валидацию непустых выбранных списков
3. Генерацию user_name через [`_generate_unique_user_name`](#_generate_unique_user_namedata-liststr---dict)
4. Сохранение настроек в БД (`saved_data_creating_channels`)
5. Отправку данных через сигнал `data_returned`

**Логика работы:**
- Показывает предупреждения если:
  - Не выбран ни один список
  - Выбран пустой список
  - Есть невалидные user_name
- Сохраняет данные в формате:
```python
{
    'first_list': str,       # Текст первого списка
    'second_list': str,      # Текст второго списка
    'third_list': str,       # Текст третьего списка
    'use_first_list': bool,  # Флаг использования первого списка
    'use_second_list': bool, # Флаг использования второго списка
    'use_third_list': bool,  # Флаг использования третьего списка
    'set_numbers_end_user_name': bool # Флаг добавления цифр
}
```

#### `_remove_spaces(text_edit: QTextEdit)`
**Описание:**  
Удаляет пробелы из поля ввода, сохраняя позицию курсора.

**Параметры:**
- `text_edit` (QTextEdit): Поле ввода для очистки

### Сигналы
```python
data_returned = pyqtSignal(dict)
```
Отправляет словарь с сохраненными данными при успешном завершении.

### Особенности реализации
1. **Генерация комбинаций:**
   - Использует `itertools.product` для декартова произведения списков
   - Поддерживает от 1 до 3 списков слов
   - Автоматическая обработка пустых списков

2. **Валидация:**
   - Проверка длины через `len()`
   - Проверка первого/последнего символа
   - Проверка запрещенных имен через прямое сравнение
   - Удаление дубликатов через преобразование в `set`

3. **Интеграция:**
   - Сохраняет данные в таблицу `saved_data_creating_channels`
   - Использует стандартные диалоги ([`DialogInfo`](#диалоговое-окно-с-информацией-infopy))
   - Совместим с [`create_channel.py`](#главный-раздел-create_channelpy)

### Пример использования
```python
# Создание диалога с начальными данными
dialog = DialogUserNameForChannel({
    'first_list': "канал\nчат",
    'second_list': "новый\nлучший", 
    'third_list': "",
    'use_first_list': True,
    'use_second_list': True,
    'use_third_list': False,
    'set_numbers_end_user_name': True
})

# Подключение обработчика результата
dialog.data_returned.connect(handler)
dialog.exec_()
```

### Связи с другими модулями
- Использует [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для показа справки
- Сохраняет данные в таблицу `saved_data_creating_channels` БД
- Интегрирован с [`create_channel.py`](#главный-раздел-create_channelpy) через сигнал `data_returned`



## Раздел инвайт (invite.py)  
### Главный раздел (invite.py)  

### Общее описание  
Модуль `invite.py` реализует функционал массового приглашения пользователей в Telegram-группы или каналы. Основные возможности:  
- Приглашение пользователей через список юзернеймов  
- Использование главных аккаунтов для назначения прав администратора активным аккаунтам  
- Поддержка прокси (SOCKS5)  
- Ограничение количества приглашений с одного аккаунта  
- Обработка ошибок и ведение статистики  

**Ключевые особенности:**  
- Двухуровневая система аккаунтов (главные и активные)  
- Многопоточная реализация через `QThread`  
- Интеграция с основной БД проекта  
- Автоматическое восстановление при ошибках  

### Классы  

#### `InvaiteOneStream(QThread)`  
Поток для выполнения приглашений. Каждый экземпляр работает с одним главным аккаунтом и несколькими активными.  

**Конструктор:**  
```python  
def __init__(self, name_group: str, user_list: list, time_sleep: int,  
             max_invite: int, max_invite_from_one_account: int,  
             use_proxy: bool, ip: str, port: int, login: str, password: str)  
```  

**Параметры:**  
- `name_group` - Юзернейм группы/канала для приглашения  
- `user_list` - Список юзернеймов для приглашения  
- `time_sleep` - Задержка между приглашениями (секунды)  
- `max_invite` - Максимальное общее количество приглашений  
- `max_invite_from_one_account` - Максимум приглашений с одного активного аккаунта  
- `use_proxy` - Флаг использования прокси  
- `ip`, `port`, `login`, `password` - Данные прокси  

**Сигналы:**  
```python  
task_done = pyqtSignal(str, list, bool, bool, bool, str, bool)  
```  
Возвращает:  
1. Текст для лога (`str`)  
2. Список использованных юзернеймов (`list`)  
3. Флаг успешного приглашения (`bool`)  
4. Флаг неудачного приглашения (`bool`)  
5. Флаг бана аккаунта (`bool`)  
6. Текст ошибки (`str`)  
7. Флаг завершения работы (`bool`)  

**Методы:**  

##### `run()`  
Точка входа потока. Запускает асинхронную задачу `run_2()`.  

##### `async run_2()`  
Основная логика работы:  
1. Настройка прокси (если `use_proxy=True`)  
2. Подключение к главному аккаунту  
3. Для каждого активного аккаунта:  
   - Взаимное добавление в контакты  
   - Назначение администратором в целевой группе  
   - Выполнение приглашений через метод `invite()`  
   - Снятие прав администратора  

##### `async invite(path_in_account: str, channel: InputChannel) -> bool`  
Выполняет приглашения через указанный активный аккаунт.  

**Параметры:**  
- `path_in_account` - Путь к папке аккаунта  
- `channel` - Объект канала (`InputChannel`)  

**Возвращает:**  
- `True` - если нужно остановить процесс  
- `False` - для продолжения работы  

**Логика работы:**  
1. Подключение к аккаунту  
2. Для каждого юзернейма в `user_list`:  
   - Проверка флага остановки из БД  
   - Проверка лимитов приглашений  
   - Попытка приглашения (`InviteToChannelRequest`)  
   - Обработка ошибок (приватность, бан и др.)  

##### `working_witch_accounts_in_banned()`  
Обрабатывает аккаунты с ошибками через [`error_handler`](#обработчик-ошибок-error_handlerpy).  

##### `update_last_used(account_id: int)`  
Обновляет время последнего использования аккаунта в БД.  

#### `WindowInvite(WindowInviteUi)`  
Главное окно управления процессом приглашения. Наследуется от сгенерированного UI.  

**Атрибуты:**  
- `invite_start` - Флаг активности процесса  
- `file_path_for_invite` - Путь к файлу с юзернеймами  
- `user_name_list_to` - Список юзернеймов для приглашения  
- `active_threads` - Список активных потоков  

**Методы:**  

##### Основные  
- `_start_invite()` - Запуск/остановка процесса  
- `_clear_conclusion()` - Очистка лога и статистики  
- `_transition()` - Переключение между окнами программы  

##### Обработчики  
- `_handler_signal()` - Обработчик сигналов от потоков  

##### Вспомогательные  
- `_show_user_name()` - Открытие файла с юзернеймами в блокноте  
- `_set_default_style()` - Восстановление стиля полей ввода  
- `_stop_invite()` - Остановка всех потоков  

### Логика работы  

1. **Подготовка:**  
   - Проверка заполненности обязательных полей  
   - Загрузка юзернеймов из файла `user_names_for_invite.txt`  
   - Проверка наличия аккаунтов (главных и активных)  
   - Проверка прокси через [`check_proxy`](#проверка-прокси-check_proxypy)  

2. **Запуск:**  
   - Создание потока `InvaiteOneStream`  
   - Подключение обработчика сигналов  

3. **Выполнение приглашений:**  
   - Главный аккаунт назначает активный аккаунт администратором  
   - Активный аккаунт приглашает пользователей  
   - Обработка ошибок (бан, приватность и др.)  

4. **Завершение:**  
   - Обновление списка использованных юзернеймов  
   - Сохранение оставшихся юзернеймов в файл  
   - Восстановление оригинального socket  

### Пример использования  

```python  
# Создание потока  
invite = InvaiteOneStream(  
    name_group="test_group",  
    user_list=["user1", "user2"],  
    time_sleep=10,  
    max_invite=100,  
    max_invite_from_one_account=20,  
    use_proxy=True,  
    ip="proxy_ip",  
    port=1080,  
    login="user",  
    password="pass"  
)  

# Подключение обработчика  
invite.task_done.connect(handler)  
invite.start()  # Запуск  
```  

### Особенности реализации  

1. **Безопасность:**  
   - Восстановление оригинального socket после завершения  
   - Гарантированное отключение клиентов Telethon  

2. **Обработка ошибок:**  
   - Перемещение проблемных аккаунтов через [`error_handler`](#обработчик-ошибок-error_handlerpy)  
   - Логирование всех ошибок  

3. **Производительность:**  
   - Равномерное распределение нагрузки между аккаунтами  
   - Минимизация блокировок UI  

4. **Интеграция:**  
   - Использует общие механизмы работы с прокси  
   - Сохраняет статистику в БД  

Модуль тесно интегрирован с основной БД проекта (`data_base.sqlite3`) и другими компонентами системы.

## Раздел рассылка по Юзерам (mailing_by_users.py)

## Главный раздел (mailing_by_users.py)

### Общее описание
Модуль `mailing_by_users.py` реализует функционал массовой рассылки сообщений пользователям Telegram через аккаунты программы. Поддерживает:
- Отправку текстовых сообщений и файлов
- Настройку задержки между сообщениями
- Ограничение количества сообщений с одного аккаунта
- Многопоточную рассылку
- Обработку ошибок и ведение статистики

**Ключевые особенности:**
- Работа с прокси (SOCKS5)
- Валидация входных данных
- Логирование процесса рассылки
- Гибкая система управления потоками

### Классы

#### `MailingWithStreams(QThread)`
Поток для многопоточной рассылки. Каждый экземпляр работает с одним аккаунтом.

**Конструктор:**
```python
def __init__(self, id_account: int, message: str, user_list: list, time_sleep: int, 
             use_file_for_message: bool, file_path: str, use_proxy: bool, 
             ip: str, port: int, login: str, password: str)
```

**Параметры:**
- `id_account` - ID папки аккаунта в директории `active_accounts`
- `message` - Текст сообщения (поддерживает HTML разметку)
- `user_list` - Список юзернеймов для рассылки
- `time_sleep` - Задержка между сообщениями в секундах
- `use_file_for_message` - Флаг отправки файла
- `file_path` - Путь к файлу для отправки
- `use_proxy` - Флаг использования прокси
- `ip`, `port`, `login`, `password` - Данные прокси

**Методы:**
- `run()` - Точка входа потока
- `run_2()` - Основная асинхронная логика рассылки
- `quit_async()` - Асинхронное завершение потока

**Сигналы:**
```python
task_done = pyqtSignal(str, list, bool, list, list, str, list, bool)
```
Возвращает:
1. Текст для лога
2. Статистику [успешные, неудачные]
3. Флаг бана аккаунта
4. Обработанные юзернеймы
5. Данные аккаунта [TG ID, время использования]
6. Текст ошибки
7. Данные об ошибке [тип, ID аккаунта]
8. Флаг завершения работы

#### `MailingOneStream(QThread)`
Поток для однопоточной рассылки. Последовательно использует все доступные аккаунты.

**Конструктор:**
```python
def __init__(self, message: str, user_list: list, time_sleep: int, 
             max_message: int, max_message_per_account: int,
             use_file_for_message: bool, file_path: str, use_proxy: bool)
```

**Методы:**
- `run()` - Основной цикл рассылки
- `mailing()` - Логика обработки одного аккаунта
- `quit_async()` - Асинхронное завершение

**Сигналы:**
```python
task_done = pyqtSignal(str, list, str, bool)
```
Возвращает:
1. Текст для лога
2. Статистику [успешные, неудачные, забаненные]
3. Текст ошибки
4. Флаг завершения

#### `WindowMailingByUsers(WindowMailingByUsersUi)`
Главное окно управления рассылкой. Наследуется от сгенерированного UI.

**Атрибуты:**
- `mailing_start` - Флаг активности рассылки
- `file_path_for_mailing` - Путь к файлу для отправки
- `active_threads` - Список активных потоков
- `original_socket` - Оригинальный socket до изменения прокси
- Статистические переменные (`quantity_remaining_message`, `count_attempts` и др.)

**Методы:**

##### Основные
- `start()` - Запуск/остановка рассылки
- `stop_mailing()` - Остановка всех потоков
- `clear_conclusion()` - Очистка лога и статистики

##### Обработчики
- `handler_signal()` - Обработчик сигналов однопоточной рассылки
- `handler_signal_with_streams()` - Обработчик многопоточной рассылки

##### Вспомогательные
- `check_user_name_file()` - Проверка файла с юзернеймами
- `choose_file_for_mailing()` - Выбор файла для отправки
- `line_edit_quantity_editing_finished()` - Валидация количества потоков
- `get_info_about_thread()` - Информация о лимитах потоков

### Логика работы

1. **Подготовка:**
   - Проверка валидности HTML разметки через [`check_html_parse`](#проверка-html-разметки-check_html_parsepy)
   - Валидация файла с юзернеймами (регулярное выражение `r'^(?=.*[A-Za-z])[\w@]+$'`)
   - Проверка прокси через [`check_proxy`](#проверка-прокси-check_proxypy)

2. **Запуск:**
   - Для многопоточной: равномерное распределение юзернеймов между потоками
   - Для однопоточной: последовательная обработка аккаунтами

3. **Обработка ошибок:**
   - Ошибки аккаунтов обрабатываются через [`error_handler`](#обработчик-ошибок-error_handlerpy)
   - Ошибки сообщений логируются (некорректный UTF-8, слишком длинные и т.д.)

4. **Завершение:**
   - Обновление времени последнего использования аккаунтов
   - Сохранение неотправленных юзернеймов в файл
   - Восстановление оригинального socket

### Примеры использования

**Запуск однопоточной рассылки:**
```python
mailing = MailingOneStream(
    message="Test message",
    user_list=["user1", "user2"],
    time_sleep=5,
    max_message=100,
    max_message_per_account=10,
    use_file_for_message=False,
    file_path="",
    use_proxy=True
)
mailing.task_done.connect(handler)
mailing.start()
```

**Многопоточная рассылка:**
```python
for id_account in range(threads_count):
    mailing = MailingWithStreams(
        id_account=id_account,
        message="Test",
        user_list=users_chunk,
        time_sleep=5,
        use_file_for_message=False,
        file_path="",
        use_proxy=True,
        ip="proxy_ip",
        port=1080,
        login="user",
        password="pass"
    )
    mailing.task_done.connect(handler)
    mailing.start()
    active_threads.append(mailing)
```

### Особенности реализации
1. **Работа с файлами:**
   - Максимальный размер файла - 2GB
   - Автоматическая очистка временных файлов при старте

2. **Безопасность:**
   - Восстановление оригинального socket после завершения
   - Обработка исключений при работе с БД

3. **Производительность:**
   - Оптимальное распределение нагрузки между потоками
   - Минимизация блокировок при работе с общими ресурсами

4. **Логирование:**
   - Детальная статистика отправки
   - Временные метки всех событий

Модуль интегрирован с основной БД программы и использует общие механизмы обработки ошибок и работы с прокси.



## Раздел парсинг (parser.py)
## Главный раздел (parser.py)

### Общее описание
Модуль `parser.py` реализует функционал парсинга пользователей из Telegram-чатов с возможностью фильтрации по различным критериям. Основные возможности:
- Парсинг участников из указанных чатов
- Фильтрация по полу, языку имени, наличию фото, телефона, премиум-статусу
- Фильтрация по времени последнего онлайна
- Работа через прокси (SOCKS5)
- Сохранение результатов в файл и возможность их экспорта/импорта

**Ключевые особенности:**
- Использование многопоточной архитектуры через `QThread`
- Интеграция с БД для фильтрации по именам
- Поддержка временных зон (Москва)
- Обработка различных ошибок Telegram API

### Классы

#### `Parsing(QThread)`
Поток для выполнения парсинга. Наследуется от `QThread` для работы в отдельном потоке.

**Конструктор:**
```python
def __init__(self, all_chats: list, online_not_less_than: int = 0, 
             online_more_than: int = 0, gender: str = '',
             premium_filter: bool = False, photo_filter: bool = False,
             phone_filter: bool = False, use_language_rus_name: bool = False,
             use_language_eng_name: bool = False, use_proxy: bool = False,
             id_proxy: str = '', port: int = 0, login: str = '', password: str = '')
```

**Параметры:**
- `all_chats` - Список чатов для парсинга
- Фильтры:
  - `online_not_less_than` - Последний онлайн не менее N дней назад
  - `online_more_than` - Последний онлайн более N дней назад
  - `gender` - Пол ('man' или 'woman')
  - `premium_filter` - Только премиум пользователи
  - `photo_filter` - Только с фото
  - `phone_filter` - Только с телефоном
  - `use_language_rus_name` - Только русские имена
  - `use_language_eng_name` - Только английские имена
- Настройки прокси:
  - `use_proxy` - Флаг использования прокси
  - `id_proxy`, `port`, `login`, `password` - Данные прокси

**Сигналы:**
```python
task_done = pyqtSignal(str, list, bool)
```
Возвращает:
1. Текст для лога
2. Список спарсенных юзернеймов
3. Флаг завершения парсинга

**Методы:**
- `run()` - Точка входа потока
- `parsing()` - Основная асинхронная логика парсинга
- `quit_async()` - Асинхронное завершение потока

#### `WindowParser(WindowParserUi)`
Главное окно управления парсингом. Наследуется от сгенерированного UI.

**Атрибуты:**
- `launched_parsing` - Флаг активности процесса парсинга
- `active_threads` - Список активных потоков
- `root_project_dir` - Корневая директория проекта ('..')
- `switch_window` - Функция переключения между окнами

**Методы:**

##### Основные
- `_start_parsing()` - Запуск/остановка парсинга
- `_show_parsing_result()` - Отображение результатов парсинга
- `_uploads_user_list()` - Экспорт списка пользователей
- `_question_input_file()` - Запрос подтверждения перед импортом списка
- `_start_input_file()` - Импорт списка пользователей

##### Обработчики фильтров
- `_change_last_online()` - Переключение фильтров времени онлайна
- `_change_gender()` - Переключение фильтров по полу
- `_change_language_name()` - Переключение фильтров по языку имени

##### Вспомогательные
- `_set_default_style()` - Сброс стиля текстового поля
- `_update_txt_file()` - Обновление файла с результатами
- `_parsing_done()` - Обработчик завершения парсинга
- `_transition()` - Переключение между окнами программы

### Логика работы

1. **Подготовка:**
   - Проверка заполненности поля с чатами
   - Проверка прокси через [`check_proxy`](#проверка-прокси-check_proxypy) (если включено)
   - Проверка наличия активных аккаунтов

2. **Парсинг:**
   - Подключение к аккаунту через `TDesktop` и `Telethon`
   - Получение списка участников чата через `GetParticipantsRequest`
   - Итерация по участникам с проверкой:
     - Не является ли ботом
     - Имеет ли username
     - Проходит ли по всем заданным фильтрам

3. **Фильтрация:**
   - По времени онлайна (с учетом временной зоны Москвы)
   - По полу и языку имени (через БД `data_base_for_parsing.sqlite3`)
   - По наличию фото, телефона, премиум-статуса

4. **Сохранение результатов:**
   - Удаление дубликатов
   - Добавление новых пользователей в файл `parsing_result.txt`
   - Обновление интерфейса

5. **Обработка ошибок:**
   - Ошибки аккаунтов обрабатываются через [`error_handler`](#обработчик-ошибок-error_handlerpy)
   - Ошибки чатов (не найден, приватный и др.) логируются

### Примеры использования

**Запуск парсинга:**
```python
# Создание потока
parser = Parsing(
    all_chats=['chat1', 'chat2'],
    online_not_less_than=7,
    gender='man',
    photo_filter=True,
    use_proxy=True,
    id_proxy='proxy_ip',
    port=1080,
    login='user',
    password='pass'
)

# Подключение обработчика и запуск
parser.task_done.connect(handler)
parser.start()
```

### Особенности реализации

1. **Фильтрация:**
   - Использует БД `data_base_for_parsing.sqlite3` для проверки имен
   - Поддерживает временную зону Москвы через `pytz`

2. **Работа с файлами:**
   - Автоматическое обновление `parsing_result.txt`
   - Поддержка экспорта/импорта списков

3. **Безопасность:**
   - Восстановление оригинального socket после завершения
   - Гарантированное отключение клиента Telethon

4. **Производительность:**
   - Многопоточная архитектура
   - Оптимизированная работа с БД

5. **Интеграция:**
   - Использует [`check_proxy`](#проверка-прокси-check_proxypy) для проверки прокси
   - Обрабатывает ошибки через [`error_handler`](#обработчик-ошибок-error_handlerpy)
   - Сохраняет результаты в `working_files/parsing_result.txt`

Модуль тесно интегрирован с основной БД проекта и использует общие механизмы работы с прокси и обработки ошибок.




### **Раздел прокси (proxy.py)**  
### **Главный раздел (proxy.py)**  

#### **Общее описание**  
Модуль `proxy.py` отвечает за настройку и управление прокси-серверами SOCKS5 в приложении. Основные функции:  
- Отображение текущих настроек прокси из БД  
- Проверка работоспособности прокси  
- Сохранение изменённых параметров прокси  
- Управление флагом использования прокси при загрузке аккаунтов  

**Ключевые особенности:**  
- Интеграция с БД (`data_base.sqlite3`, таблица `proxy`)  
- Проверка прокси через модуль [`check_proxy`](#проверка-прокси-check_proxypy)  
- Взаимодействие с другими разделами через систему переключения окон (`switch_window`)  

---

### **Класс `WindowProxy(WindowProxyUi)`**  
Наследуется от сгенерированного UI-класса `WindowProxyUi`. Управляет интерфейсом настроек прокси.  

#### **Конструктор:**  
```python  
def __init__(self, switch_window=None):  
```  
- `switch_window` — функция для переключения между окнами приложения.  

**Инициализирует:**  
- Подключение к БД и загрузку текущих настроек прокси (`show_data`)  
- Настройку Qt plugins path (необходимо для корректной работы PyQt5)  
- Подключение обработчиков событий для кнопок и полей ввода  

---

### **Методы:**  

#### **`show_data(self)`**  
**Описание:**  
Загружает текущие настройки прокси из БД (таблица `proxy`) и отображает их в соответствующих полях интерфейса.  

**Логика работы:**  
1. Подключается к БД:  
   ```python  
   connection = sqlite3.connect(self.root_project_dir + "/working_files/data_base.sqlite3")  
   cursor = connection.cursor()  
   ```  
2. Получает данные:  
   ```python  
   cursor.execute("SELECT ip, port, login, password, use_proxy_to_enter FROM proxy")  
   data_proxy = cursor.fetchone()  
   ```  
3. Заполняет поля:  
   - `lineEdit_ip_socks5` — IP прокси  
   - `lineEdit_port_socks5` — порт  
   - `lineEdit_login_socks5` — логин  
   - `lineEdit_password_socks5` — пароль  
   - `checkBox_use_proxy_for_loading` — флаг использования прокси  

**Использует:**  
- [`sqlite3`](#бд) для работы с базой данных  

---

#### **`_change_checkbox(self)`**  
**Описание:**  
Обновляет значение флага `use_proxy_to_enter` в БД при изменении состояния чекбокса `checkBox_use_proxy_for_loading`.  

**Логика работы:**  
1. Получает текущее состояние чекбокса:  
   ```python  
   result = self.checkBox_use_proxy_for_loading.isChecked()  
   ```  
2. Обновляет БД:  
   ```python  
   cursor.execute("UPDATE proxy SET use_proxy_to_enter = ?", (1 if result else 0,))  
   ```  

**Возвращает:**  
- Нет, но сохраняет изменения в БД.  

---

#### **`_open_info(self)`**  
**Описание:**  
Открывает информационное окно [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) с инструкцией по использованию прокси.  

**Отображаемый текст:**  
```  
Для получения актуальных данных о аккаунте, необходимо войти в него.  
Вход происходит при запуске приложения.  
Можно входить в него с использованием прокси SOCKS5.  
```  

**Использует:**  
- [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для показа сообщения  

---

#### **`_editing_finished(self)`**  
**Описание:**  
Сохраняет изменения в полях ввода (IP, порт, логин, пароль) в БД при потере фокуса (событие `editingFinished`).  

**Логика работы:**  
1. Проверяет корректность порта (должен быть числом).  
2. Обновляет данные в БД:  
   ```python  
   cursor.execute("UPDATE proxy SET ip = ?, port = ?, login = ?, password = ?",  
                  (self.lineEdit_ip_socks5.text(), port,  
                   self.lineEdit_login_socks5.text(), self.lineEdit_password_socks5.text()))  
   ```  

**Обрабатывает:**  
- Ошибки преобразования порта в число (`try-except`)  

---

#### **`_check_proxy(self)`**  
**Описание:**  
Проверяет работоспособность прокси через модуль [`check_proxy`](#проверка-прокси-check_proxypy) и выводит результат в [`DialogInfo`](#диалоговое-окно-с-информацией-infopy).  

**Логика работы:**  
1. Вызывает `check_proxy` с текущими параметрами:  
   ```python  
   result = check_proxy(  
       self.lineEdit_ip_socks5.text(),  
       int(self.lineEdit_port_socks5.text()),  
       self.lineEdit_login_socks5.text(),  
       self.lineEdit_password_socks5.text()  
   )  
   ```  
2. Отображает результат:  
   - Успех: `Успешное подключение к прокси! IP: {result}`  
   - Ошибка: `К прокси не удалось подключиться!`  

**Использует:**  
- [`check_proxy`](#проверка-прокси-check_proxypy) для проверки  
- [`DialogInfo`](#диалоговое-окно-с-информацией-infopy) для вывода результата  

---

### **Функция `application()`**  
**Описание:**  
Точка входа для запуска окна настроек прокси как самостоятельного приложения.  

**Логика работы:**  
1. Создаёт экземпляр `QApplication`.  
2. Инициализирует окно `WindowProxy`.  
3. Запускает цикл обработки событий.  

**Обрабатывает:**  
- Исключения при запуске (выводит ошибку в консоль).  

---

### **Особенности реализации**  
1. **Интеграция с БД:**  
   - Все изменения сохраняются в таблице `proxy`.  
   - Параметры загружаются при старте окна.  

2. **Проверка прокси:**  
   - Используется асинхронная проверка через [`check_proxy`](#проверка-прокси-check_proxypy).  

3. **UI/UX:**  
   - Поля ввода обновляют БД только после потери фокуса.  
   - Чекбокс мгновенно применяет изменения.  

4. **Обработка ошибок:**  
   - Некорректный порт заменяется на `None`.  

---

### **Пример использования**  
```python  
# Создание и отображение окна  
proxy_window = WindowProxy()  
proxy_window.show()  
```  

### **Связи с другими модулями**  
- Использует [`check_proxy`](#проверка-прокси-check_proxypy) для проверки подключения.  
- Сохраняет данные в таблицу `proxy` БД [`data_base.sqlite3`](#бд).  
- Переключается на другие окна через `switch_window`.




